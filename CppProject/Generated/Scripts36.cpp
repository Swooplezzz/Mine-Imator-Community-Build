/*
	NOTE:
	This file was autogenerated by CppGen, changes may be overwritten and forever lost!
	Modify at your own risk!
	
	[ Generated on 2023.05.16 16:36:27 ]
*/

#include "Scripts.hpp"

namespace CppProject
{
	VarType model_file_load_shape(Scope<obj_model_part> self, VarType map, IntType res)
	{
		if (!is_undefined(DsMap(map).Value(/*"visible"*/ STR(1803))) && !(DsMap(map).Value(/*"visible"*/ STR(1803)) > 0))
			return IntType(0);
		if (!is_string(DsMap(map).Value(/*"type"*/ STR(794))))
		{
			log({ /*"Missing parameter \"type\""*/ STR(1837) });
			return null_;
		}
		if (!ds_list_valid(DsMap(map).Value(/*"from"*/ STR(833))))
		{
			log({ /*"Missing array \"from\""*/ STR(1838) });
			return null_;
		}
		if (!ds_list_valid(DsMap(map).Value(/*"to"*/ STR(834))))
		{
			log({ /*"Missing array \"to\""*/ STR(1839) });
			return null_;
		}
		if (!ds_list_valid(DsMap(map).Value(/*"uv"*/ STR(842))))
		{
			log({ /*"Missing array \"uv\""*/ STR(1840) });
			return null_;
		}
		withOne (obj_model_shape, (new obj_model_shape)->id, self->id)
		{
			self->type = DsMap(map).Value(/*"type"*/ STR(794));
			self->description = value_get_string(DsMap(map).Value(/*"description"*/ STR(1798)), /*""*/ STR(0));
			if (is_string(DsMap(map).Value(/*"texture"*/ STR(553))))
			{
				self->texture_name = DsMap(map).Value(/*"texture"*/ STR(553));
				self->texture_inherit = self->id;
				self->texture_material_inherit = self->id;
				self->texture_normal_inherit = self->id;
				if (!ds_list_valid(DsMap(map).Value(/*"texture_size"*/ STR(1793))))
				{
					log({ /*"Missing array \"texture_size\""*/ STR(1794) });
					return null_;
				}
				if (res != null_)
				{
					model_file_load_texture(self->texture_name, res);
					self->texture_material_name = value_get_string(DsMap(map).Value(/*"texture_material"*/ STR(1799)), /*""*/ STR(0));
					self->texture_normal_name = value_get_string(DsMap(map).Value(/*"texture_normal"*/ STR(1800)), /*""*/ STR(0));
					if (self->texture_material_name != /*""*/ STR(0))
						model_file_load_texture_material(self->texture_material_name, res);
					else
						self->texture_material_inherit = ObjType(obj_model_part, self.otherId)->texture_material_inherit;
					
					if (self->texture_normal_name != /*""*/ STR(0))
						model_file_load_tex_normal(self->texture_normal_name, res);
					else
						self->texture_normal_inherit = ObjType(obj_model_part, self.otherId)->texture_normal_inherit;
					
				}
				else
				{
					self->texture_material_name = self->texture_name;
					self->texture_normal_name = self->texture_name;
				}
				
				self->texture_size = value_get_point2D(DsMap(map).Value(/*"texture_size"*/ STR(1793)));
				RealType size = max({ self->texture_size.Value(X_), self->texture_size.Value(Y_) });
				self->texture_size = vec2(size, size);
			}
			else
			{
				self->texture_name = /*""*/ STR(0);
				self->texture_material_name = /*""*/ STR(0);
				self->texture_normal_name = /*""*/ STR(0);
				self->texture_inherit = ObjType(obj_model_part, self.otherId)->texture_inherit;
				self->texture_material_inherit = ObjType(obj_model_part, self.otherId)->texture_material_inherit;
				self->texture_normal_inherit = ObjType(obj_model_part, self.otherId)->texture_normal_inherit;
				self->texture_size = idVar(self->texture_inherit, texture_size);
			}
			
			self->color_inherit = value_get_real(DsMap(map).Value(/*"color_inherit"*/ STR(1807)), true);
			self->color_blend = value_get_color(DsMap(map).Value(/*"color_blend"*/ STR(1808)), c_white);
			self->color_alpha = value_get_real(DsMap(map).Value(/*"color_alpha"*/ STR(1809)), IntType(1));
			if (is_real(/*"color_emissive"*/ STR(1810)))
				self->color_emissive = value_get_real(DsMap(map).Value(/*"color_emissive"*/ STR(1810)), IntType(0));
			else
				self->color_emissive = value_get_real(DsMap(map).Value(/*"color_brightness"*/ STR(1811)), IntType(0));
			
			self->color_mix = value_get_color(DsMap(map).Value(/*"color_mix"*/ STR(1812)), c_black);
			self->color_mix_percent = value_get_real(DsMap(map).Value(/*"color_mix_percent"*/ STR(1813)), IntType(0));
			if (self->color_inherit > 0)
			{
				self->color_blend = color_multiply(self->color_blend, ObjType(obj_model_part, self.otherId)->color_blend);
				self->color_alpha *= ObjType(obj_model_part, self.otherId)->color_alpha;
				self->color_emissive = clamp(self->color_emissive + ObjType(obj_model_part, self.otherId)->color_emissive, IntType(0), IntType(1));
				self->color_mix = color_add(self->color_mix, ObjType(obj_model_part, self.otherId)->color_mix);
				self->color_mix_percent = clamp(self->color_mix_percent + ObjType(obj_model_part, self.otherId)->color_mix_percent, IntType(0), IntType(1));
			}
			if (self->color_mix_percent > IntType(0))
				ObjType(obj_model_part, self.otherId)->part_mixing_shapes = true;
			self->minecraft_color = c_white;
			self->texture_mirror = value_get_real(DsMap(map).Value(/*"texture_mirror"*/ STR(1841)), false);
			self->invert = value_get_real(DsMap(map).Value(/*"invert"*/ STR(1835)), false);
			self->hide_front = value_get_real(DsMap(map).Value(/*"hide_front"*/ STR(1842)), false);
			self->hide_back = value_get_real(DsMap(map).Value(/*"hide_back"*/ STR(1843)), false);
			if (is_bool(DsMap(map).Value(/*"hide_backface"*/ STR(1844))))
				self->hide_back = DsMap(map).Value(/*"hide_backface"*/ STR(1844));
			self->face_camera = value_get_real(DsMap(map).Value(/*"face_camera"*/ STR(1845)), false);
			self->item_bounce = value_get_real(DsMap(map).Value(/*"item_bounce"*/ STR(1846)), false);
			self->move_required_array = value_get_point3D(DsMap(map).Value(/*"move_required"*/ STR(1847)), vec3(-IntType(1), -IntType(1), -IntType(1)));
			if (!array_equals(VarType::CreateRef(self->move_required_array), VarType::CreateRef(vec3(-IntType(1)))))
				self->move_required = true;
			else
				self->move_required = false;
			
			self->from_noscale = value_get_point3D(DsMap(map).Value(/*"from"*/ STR(833)));
			self->to_noscale = value_get_point3D(DsMap(map).Value(/*"to"*/ STR(834)));
			if (self->type == /*"plane"*/ STR(1848))
				self->to_noscale[Y_] = self->from_noscale.Value(Y_);
			self->inflate = vec3(value_get_real(DsMap(map).Value(/*"inflate"*/ STR(1849)), IntType(0)));
			if (self->type == /*"plane"*/ STR(1848))
				self->to_noscale[Y_] = self->from_noscale.Value(Y_);
			self->is3d = false;
			if (self->type == /*"plane"*/ STR(1848))
			{
				self->is3d = value_get_real(DsMap(map).Value(/*"3d"*/ STR(1850)), false);
				if (self->is3d > 0)
				{
					ObjType(obj_model_part, self.otherId)->has_3d_plane = true;
					self->to_noscale[Y_] += IntType(1);
				}
				else
					self->inflate.Real(Y_) = IntType(0);
				
			}
			self->position_noscale = value_get_point3D(DsMap(map).Value(/*"position"*/ STR(40)), point3D(IntType(0), IntType(0), IntType(0)));
			self->position = point3D_mul(self->position_noscale, ObjType(obj_model_part, self.otherId)->scale);
			self->rotation = value_get_point3D(DsMap(map).Value(/*"rotation"*/ STR(835)), vec3(IntType(0), IntType(0), IntType(0)));
			self->scale = value_get_point3D(DsMap(map).Value(/*"scale"*/ STR(1802)), vec3(IntType(1), IntType(1), IntType(1)));
			self->scale = vec3_mul(self->scale, ObjType(obj_model_part, self.otherId)->scale);
			self->from = point3D_mul(point3D_sub(self->from_noscale, self->inflate), self->scale);
			self->to = point3D_mul(point3D_add(self->to_noscale, self->inflate), self->scale);
			self->locked = value_get_real(DsMap(map).Value(/*"locked"*/ STR(930)), false);
			self->bend_shape = value_get_real(DsMap(map).Value(/*"bend"*/ STR(1817)), true);
			self->bend_part = ObjType(obj_model_part, self.otherId)->bend_part;
			self->bend_axis = ObjType(obj_model_part, self.otherId)->bend_axis;
			self->bend_direction_min = ObjType(obj_model_part, self.otherId)->bend_direction_min;
			self->bend_direction_max = ObjType(obj_model_part, self.otherId)->bend_direction_max;
			self->bend_default_angle = ObjType(obj_model_part, self.otherId)->bend_default_angle;
			self->bend_offset = ObjType(obj_model_part, self.otherId)->bend_offset;
			self->bend_size = ObjType(obj_model_part, self.otherId)->bend_size;
			self->bend_invert = ObjType(obj_model_part, self.otherId)->bend_invert;
			self->matrix = matrix_create(self->position, vec3(IntType(0)), vec3(IntType(1)));
			self->uv = value_get_point2D(DsMap(map).Value(/*"uv"*/ STR(842)));
			self->wind_wave = e_vertex_wave_NONE;
			self->wind_wave_zmin = null_;
			self->wind_wave_zmax = null_;
			VarType windmap = DsMap(map).Value(/*"wind"*/ STR(137));
			if (ds_map_valid(windmap))
			{
				if (is_string(DsMap(windmap).Value(/*"axis"*/ STR(821))))
				{
					if (DsMap(windmap).Value(/*"axis"*/ STR(821)) == /*"y"*/ STR(822))
						self->wind_wave = e_vertex_wave_Z_ONLY;
					else
						self->wind_wave = e_vertex_wave_ALL;
					
				}
				if (is_real(DsMap(windmap).Value(/*"ymin"*/ STR(823))))
					self->wind_wave_zmin = DsMap(windmap).Value(/*"ymin"*/ STR(823));
				if (is_real(DsMap(windmap).Value(/*"ymax"*/ STR(1851))))
					self->wind_wave_zmax = DsMap(windmap).Value(/*"ymax"*/ STR(1851));
			}
			if (self->type == /*"block"*/ STR(529))
			{
				self->vbuffer_default = model_shape_generate_block(ScopeAny(self), vec3(IntType(0)));
				if (ObjType(obj_model_part, self.otherId)->name == /*"head"*/ STR(893) && global::player_head_vbuffer == null_)
					global::player_head_vbuffer = self->vbuffer_default;
			}
			else
				if (self->type == /*"plane"*/ STR(1848))
					self->vbuffer_default = model_shape_generate_plane(ScopeAny(self), vec3(IntType(0)));
				else
				{
					self->vbuffer_default = null_;
					log({ /*"Invalid shape type"*/ STR(1852), self->type });
					return null_;
				}
			
			
			MatrixType boundsmat = matrix_create(self->position, self->rotation, vec3(IntType(1)));
			VecType startpos = point3D_mul_matrix(self->from, boundsmat);
			VecType endpos = point3D_mul_matrix(self->to, boundsmat);
			self->bounds_start.Real(X_) = min({ startpos.Real(X_), endpos.Real(X_) });
			self->bounds_start.Real(Y_) = min({ startpos.Real(Y_), endpos.Real(Y_) });
			self->bounds_start.Real(Z_) = min({ startpos.Real(Z_), endpos.Real(Z_) });
			self->bounds_end.Real(X_) = max({ startpos.Real(X_), endpos.Real(X_) });
			self->bounds_end.Real(Y_) = max({ startpos.Real(Y_), endpos.Real(Y_) });
			self->bounds_end.Real(Z_) = max({ startpos.Real(Z_), endpos.Real(Z_) });
			ObjType(obj_model_part, self.otherId)->bounds_start.Real(X_) = min({ ObjType(obj_model_part, self.otherId)->bounds_start.Real(X_), self->bounds_start.Real(X_) });
			ObjType(obj_model_part, self.otherId)->bounds_start.Real(Y_) = min({ ObjType(obj_model_part, self.otherId)->bounds_start.Real(Y_), self->bounds_start.Real(Y_) });
			ObjType(obj_model_part, self.otherId)->bounds_start.Real(Z_) = min({ ObjType(obj_model_part, self.otherId)->bounds_start.Real(Z_), self->bounds_start.Real(Z_) });
			ObjType(obj_model_part, self.otherId)->bounds_end.Real(X_) = max({ ObjType(obj_model_part, self.otherId)->bounds_end.Real(X_), self->bounds_end.Real(X_) });
			ObjType(obj_model_part, self.otherId)->bounds_end.Real(Y_) = max({ ObjType(obj_model_part, self.otherId)->bounds_end.Real(Y_), self->bounds_end.Real(Y_) });
			ObjType(obj_model_part, self.otherId)->bounds_end.Real(Z_) = max({ ObjType(obj_model_part, self.otherId)->bounds_end.Real(Z_), self->bounds_end.Real(Z_) });
			return self->id;
		}
		
		return VarType();
	}
	
	RealType model_file_load_texture(VarType name, IntType res)
	{
		StringType ext = filename_ext(name);
		if (ext != /*".png"*/ STR(6) && ext != /*".jpg"*/ STR(729) && ext != /*".jpeg"*/ STR(730))
			return IntType(0);
		if (ObjType(obj_resource, res)->model_texture_map == null_)
			ObjType(obj_resource, res)->model_texture_map = ds_map_create();
		else
			if (!is_undefined(DsMap(ObjType(obj_resource, res)->model_texture_map).Value(name)))
				return IntType(0);
		
		DsMap(ObjType(obj_resource, res)->model_texture_map)[name] = texture_create_square(global::load_folder + /*"/"*/ STR(16) + name);
		return 0.0;
	}
	
	RealType model_file_load_texture_material(VarType name, IntType res)
	{
		StringType ext = filename_ext(name);
		if (ext != /*".png"*/ STR(6) && ext != /*".jpg"*/ STR(729) && ext != /*".jpeg"*/ STR(730))
			return IntType(0);
		if (ObjType(obj_resource, res)->model_texture_material_map == null_)
			ObjType(obj_resource, res)->model_texture_material_map = ds_map_create();
		else
			if (!is_undefined(DsMap(ObjType(obj_resource, res)->model_texture_material_map).Value(name)))
				return IntType(0);
		
		DsMap(ObjType(obj_resource, res)->model_texture_material_map)[name] = texture_create_square(global::load_folder + /*"/"*/ STR(16) + name);
		return 0.0;
	}
	
	RealType model_file_load_tex_normal(VarType name, IntType res)
	{
		StringType ext = filename_ext(name);
		if (ext != /*".png"*/ STR(6) && ext != /*".jpg"*/ STR(729) && ext != /*".jpeg"*/ STR(730))
			return IntType(0);
		if (ObjType(obj_resource, res)->model_tex_normal_map == null_)
			ObjType(obj_resource, res)->model_tex_normal_map = ds_map_create();
		else
			if (!is_undefined(DsMap(ObjType(obj_resource, res)->model_tex_normal_map).Value(name)))
				return IntType(0);
		
		DsMap(ObjType(obj_resource, res)->model_tex_normal_map)[name] = texture_create_square(global::load_folder + /*"/"*/ STR(16) + name);
		return 0.0;
	}
	
	RealType model_file_matrix_map_add_part(VarType part, MatrixType mat, IntType map, IntType hidelist)
	{
		MatrixType partmat;
		if (hidelist != null_ && ds_list_find_index(hidelist, idVar(part, name)) > -IntType(1))
			return IntType(0);
		partmat = matrix_multiply(idMat(part, default_matrix), mat);
		ds_map_add(map, idVar(part, name), partmat);
		if (idInt(part, part_list) != null_)
		{
			for (IntType p = IntType(0); p < ds_list_size(idInt(part, part_list)); p++)
				model_file_matrix_map_add_part(DsList(idInt(part, part_list)).Value(p), partmat, map, hidelist);
		}
		return 0.0;
	}
	
	IntType model_file_matrix_map_create(VarType modelfile, MatrixType mat, IntType hidelist)
	{
		IntType map = ds_map_create();
		for (IntType p = IntType(0); p < ds_list_size(idInt(modelfile, part_list)); p++)
			model_file_matrix_map_add_part(DsList(idInt(modelfile, part_list)).Value(p), mat, map, hidelist);
		return map;
	}
	
	IntType model_load(VarType map, StringType dir)
	{
		withOne (obj_model, (new obj_model)->id, noone)
		{
			if (is_string(DsMap(map).Value(/*"name"*/ STR(808))))
				self->name = DsMap(map).Value(/*"name"*/ STR(808));
			else
			{
				log({ /*"Could not find name for model"*/ STR(1853) });
				return null_;
			}
			
			if (dev_mode_debug_names && !text_exists(/*"model"*/ STR(536) + self->name))
				log({ /*"model/"*/ STR(1797) + self->name + dev_mode_name_translation_message });
			if (is_string(DsMap(map).Value(/*"file"*/ STR(115))))
				self->file = model_file_load(dir + DsMap(map).Value(/*"file"*/ STR(115)));
			else
				self->file = null_;
			
			if (is_string(DsMap(map).Value(/*"texture"*/ STR(553))))
			{
				self->texture_name_map = ds_string_map_create();
				DsMap(self->texture_name_map)[/*""*/ STR(0)] = DsMap(map).Value(/*"texture"*/ STR(553));
			}
			else
				if (ds_map_valid(DsMap(map).Value(/*"texture"*/ STR(553))))
				{
					self->texture_name_map = ds_string_map_create();
					ds_map_copy((IntType)(self->texture_name_map), (IntType)(DsMap(map).Value(/*"texture"*/ STR(553))));
				}
				else
					self->texture_name_map = null_;
			
			
			self->version = value_get_real(DsMap(map).Value(/*"version"*/ STR(87)), IntType(0));
			self->pattern_type = value_get_string(DsMap(map).Value(/*"pattern_type"*/ STR(880)), /*""*/ STR(0));
			self->states_map = null_;
			if (ds_map_valid(DsMap(map).Value(/*"states"*/ STR(816))))
			{
				self->states_map = ds_map_create();
				VarType curstate = ds_map_find_first((IntType)(DsMap(map).Value(/*"states"*/ STR(816))));
				while (!is_undefined(curstate))
				{
					if (dev_mode_debug_names && !text_exists(/*"modelstate"*/ STR(765) + curstate))
						log({ /*"model/state/"*/ STR(1854) + curstate + dev_mode_name_translation_message });
					withOne (obj_model_state, (new obj_model_state)->id, self->id)
					{
						self->name = curstate;
						IntType valuelist = ds_map_find_value((IntType)(DsMap(map).Value(/*"states"*/ STR(816))), curstate);
						self->value_amount = ds_list_size(valuelist);
						for (IntType v = IntType(0); v < self->value_amount; v++)
						{
							VarType curvalue = DsList(valuelist).Value(v);
							self->value_name[v] = DsMap(curvalue).Value(/*"value"*/ STR(818));
							self->value_file[v] = null_;
							self->value_texture_name_map[v] = null_;
							self->value_texture_material_name_map[v] = null_;
							self->value_tex_normal_name_map[v] = null_;
							self->value_shape_texture_name_map[v] = null_;
							self->value_shape_texture_material_name_map[v] = null_;
							self->value_shape_tex_normal_name_map[v] = null_;
							self->value_hide_list[v] = null_;
							self->value_shape_hide_list[v] = null_;
							self->value_color_name_map[v] = null_;
							self->value_pattern_type[v] = ObjType(obj_model, self.otherId)->pattern_type;
							if (dev_mode_debug_names && !text_exists(/*"modelstatevalue"*/ STR(768) + self->value_name.Value(v)))
								log({ /*"model/state/value/"*/ STR(1855) + self->value_name.Value(v) + dev_mode_name_translation_message });
							if (!is_undefined(DsMap(curvalue).Value(/*"file"*/ STR(115))))
								self->value_file[v] = model_file_load(dir + DsMap(curvalue).Value(/*"file"*/ STR(115)));
							if (is_string(DsMap(curvalue).Value(/*"texture"*/ STR(553))))
							{
								IntType texnamemap = ds_string_map_create();
								DsMap(texnamemap)[/*""*/ STR(0)] = DsMap(curvalue).Value(/*"texture"*/ STR(553));
								self->value_texture_name_map[v] = texnamemap;
								texnamemap = ds_string_map_create();
								DsMap(texnamemap)[/*""*/ STR(0)] = DsMap(curvalue).Value(/*"texture"*/ STR(553));
								self->value_texture_material_name_map[v] = texnamemap;
								texnamemap = ds_string_map_create();
								DsMap(texnamemap)[/*""*/ STR(0)] = DsMap(curvalue).Value(/*"texture"*/ STR(553));
								self->value_tex_normal_name_map[v] = texnamemap;
							}
							else
								if (ds_map_valid(DsMap(curvalue).Value(/*"texture"*/ STR(553))))
								{
									self->value_texture_name_map[v] = ds_map_create();
									ds_map_merge(self->value_texture_name_map.Value(v), DsMap(curvalue).Value(/*"texture"*/ STR(553)), true);
									self->value_texture_material_name_map[v] = ds_map_create();
									ds_map_merge(self->value_texture_material_name_map.Value(v), DsMap(curvalue).Value(/*"texture"*/ STR(553)), true);
									self->value_tex_normal_name_map[v] = ds_map_create();
									ds_map_merge(self->value_tex_normal_name_map.Value(v), DsMap(curvalue).Value(/*"texture"*/ STR(553)), true);
								}
							
							if (is_string(DsMap(curvalue).Value(/*"shape_texture"*/ STR(1856))))
							{
								IntType shapetexnamemap = ds_string_map_create();
								DsMap(shapetexnamemap)[/*""*/ STR(0)] = DsMap(curvalue).Value(/*"shape_texture"*/ STR(1856));
								self->value_shape_texture_name_map[v] = shapetexnamemap;
								self->value_shape_texture_material_name_map = ds_map_create();
								DsMap(shapetexnamemap)[/*""*/ STR(0)] = DsMap(curvalue).Value(/*"shape_texture"*/ STR(1856));
								self->value_shape_texture_material_name_map[v] = shapetexnamemap;
								self->value_shape_tex_normal_name_map = ds_map_create();
								DsMap(shapetexnamemap)[/*""*/ STR(0)] = DsMap(curvalue).Value(/*"shape_texture"*/ STR(1856));
								self->value_shape_tex_normal_name_map[v] = shapetexnamemap;
							}
							else
								if (ds_map_valid(DsMap(curvalue).Value(/*"shape_texture"*/ STR(1856))))
								{
									self->value_shape_texture_name_map[v] = ds_map_create();
									ds_map_merge(self->value_shape_texture_name_map.Value(v), DsMap(curvalue).Value(/*"shape_texture"*/ STR(1856)), true);
									self->value_shape_texture_material_name_map[v] = ds_map_create();
									ds_map_merge(self->value_shape_texture_material_name_map.Value(v), DsMap(curvalue).Value(/*"shape_texture"*/ STR(1856)), true);
									self->value_shape_tex_normal_name_map[v] = ds_map_create();
									ds_map_merge(self->value_shape_tex_normal_name_map.Value(v), DsMap(curvalue).Value(/*"shape_texture"*/ STR(1856)), true);
								}
							
							if (ds_list_valid(DsMap(curvalue).Value(/*"hide"*/ STR(740))))
							{
								self->value_hide_list[v] = ds_list_create();
								ds_list_copy((IntType)(self->value_hide_list.Value(v)), (IntType)(DsMap(curvalue).Value(/*"hide"*/ STR(740))));
							}
							if (ds_list_valid(DsMap(curvalue).Value(/*"shape_hide"*/ STR(1857))))
							{
								self->value_shape_hide_list[v] = ds_list_create();
								ds_list_copy((IntType)(self->value_shape_hide_list.Value(v)), (IntType)(DsMap(curvalue).Value(/*"shape_hide"*/ STR(1857))));
							}
							if (ds_map_valid(DsMap(curvalue).Value(/*"shape_color"*/ STR(1858))))
							{
								self->value_color_name_map[v] = ds_map_create();
								ds_map_merge(self->value_color_name_map.Value(v), DsMap(curvalue).Value(/*"shape_color"*/ STR(1858)), true);
							}
							if (!is_undefined(DsMap(curvalue).Value(/*"pattern_type"*/ STR(880))))
								self->value_pattern_type[v] = DsMap(curvalue).Value(/*"pattern_type"*/ STR(880));
						}
						DsMap(ObjType(obj_model, self.otherId)->states_map)[curstate] = self->id;
						curstate = ds_map_find_next((IntType)(DsMap(map).Value(/*"states"*/ STR(816))), curstate);
					}
					
				}
				
			}
			if (is_string(DsMap(map).Value(/*"default_state"*/ STR(820))))
				self->default_state = string_get_state_vars(DsMap(map).Value(/*"default_state"*/ STR(820)));
			else
				self->default_state = ArrType();
			
			return self->id;
		}
		
		return IntType(0);
	}
	
	void model_part_event_destroy(Scope<obj_model_part> self)
	{
		if (self->shape_list != null_)
		{
			for (IntType s = IntType(0); s < ds_list_size(self->shape_list); s++)
				withOne (obj_model_shape, DsList(self->shape_list).Value(s), self->id)
					instance_destroy(ScopeAny(self));
			
			ds_list_destroy(self->shape_list);
		}
		if (self->part_list != null_)
		{
			for (IntType p = IntType(0); p < ds_list_size(self->part_list); p++)
				withOne (Object, DsList(self->part_list).Value(p), self->id)
					instance_destroy(self);
			
			ds_list_destroy(self->part_list);
		}
	}
	
	RealType model_part_fill_shape_alpha_map(VarType part, IntType alphamap, VarType res, IntType texnamemap, IntType shapetexnamemap)
	{
		if (idInt(part, shape_list) == null_)
			return IntType(0);
		VarType parttexname = model_part_get_texture_name(part, texnamemap);
		for (IntType s = IntType(0); s < ds_list_size(idInt(part, shape_list)); s++)
		{
			withOne (obj_model_shape, DsList(idInt(part, shape_list)).Value(s), noone)
			{
				if (self->type == /*"plane"*/ STR(1848) && self->is3d > 0)
				{
					VarType shapetexname = parttexname;
					if (self->texture_name != /*""*/ STR(0))
						shapetexname = self->texture_name;
					if (shapetexnamemap != null_)
					{
						VarType maptexname = DsMap(shapetexnamemap).Value(self->description);
						if (!is_undefined(maptexname))
							shapetexname = maptexname;
					}
					VarType tex;
					withOne (Object, res, self->id)
						tex = res_get_model_texture(self, shapetexname);
					
					if (tex != null_)
					{
						RealType tw, th;
						VecType texsize, texsizeuv, texuv, samplepos, samplesize;
						tw = texture_width(tex);
						th = texture_height(tex);
						texsize = point3D_sub(self->to_noscale, self->from_noscale);
						texsizeuv = vec2_div(vec2(texsize.Real(X_), texsize.Real(Z_)), self->texture_size);
						texuv = vec2_div(self->uv, self->texture_size);
						samplepos = point2D(ceil(texuv.Real(X_) * tw), ceil(texuv.Real(Y_) * th));
						samplesize = vec2(ceil(texsizeuv.Real(X_) * tw), ceil(texsizeuv.Real(Y_) * th));
						IntType surf = surface_create((IntType)(samplesize.Real(X_)), (IntType)(samplesize.Real(Y_)));
						draw_texture_start();
						surface_set_target(surf);
					{
						draw_clear_alpha(c_black, 0.0);
						draw_texture_part({ tex, IntType(0), IntType(0), samplepos.Real(X_), samplepos.Real(Y_), samplesize.Real(X_), samplesize.Real(Y_) });
					}
						surface_reset_target();
						draw_texture_done();
						DsMap(alphamap)[self->id] = surface_get_alpha_array(surf);
						surface_free(surf);
					}
				}
			}
			
		}
		return 0.0;
	}
	
	RealType model_part_fill_shape_vbuffer_map(VarType part, IntType vbufmap, IntType alphamap, VecType bend)
	{
		for (IntType i = X_; i <= Z_; i++)
			bend.Real(X_ + i) = clamp(bend.Real(X_ + i), idVec(part, bend_direction_min).Real(i), idVec(part, bend_direction_max).Real(i));
		if (idInt(part, shape_list) == null_)
			return IntType(0);
		BoolType isbent = !vec3_equals(bend, vec3(IntType(0)));
		for (IntType s = IntType(0); s < ds_list_size(idInt(part, shape_list)); s++)
		{
			withOne (obj_model_shape, DsList(idInt(part, shape_list)).Value(s), noone)
			{
				DsMap(vbufmap)[self->id] = self->vbuffer_default;
				if (self->type == /*"block"*/ STR(529) && self->bend_shape > 0 && isbent)
					DsMap(vbufmap)[self->id] = model_shape_generate_block(ScopeAny(self), bend);
				else
					if (self->type == /*"plane"*/ STR(1848))
					{
						if (self->is3d > 0)
						{
							if (ds_map_valid(alphamap))
								DsMap(vbufmap)[self->id] = model_shape_generate_plane_3d(ScopeAny(self), bend, DsMap(alphamap).Value(self->id));
						}
						else
							if (isbent && self->bend_shape > 0)
								DsMap(vbufmap)[self->id] = model_shape_generate_plane(ScopeAny(self), bend);
						
					}
				
			}
			
		}
		return 0.0;
	}
	
	MatrixType model_part_get_bend_matrix(ScopeAny self, VarArgs argument)
	{
		IntType argument_count = argument.Size();
		VarType part, bend, pos, rot, sca;
		part = argument[IntType(0)];
		bend = argument[IntType(1)];
		pos = argument[IntType(2)];
		if (argument_count > IntType(3))
			sca = argument[IntType(3)];
		else
			sca = vec3(IntType(1));
		
		if (idInt(part, bend_part) == null_)
			return MAT_IDENTITY;
		for (IntType i = X_; i <= Z_; i++)
		{
			if (bend.Value(i) == IntType(0))
				continue;
			bend[i] = clamp(bend.Value(i), idVec(part, bend_direction_min).Real(i), idVec(part, bend_direction_max).Real(i));
			if (idVec(part, bend_invert).Real(i))
				bend[i] *= -1.0;
			if (!idVec(part, bend_axis).Real(i))
				bend[i] = IntType(0);
		}
		switch ((IntType)idInt(part, bend_part))
		{
			case e_part_RIGHT:
			case e_part_LEFT:
			{
				pos[X_] = idVar(part, bend_offset);
				if (self->subAssetId == ID_obj_model_shape)
					pos[X_] -= sVar(position).Value(X_);
				break;
			}
			case e_part_FRONT:
			case e_part_BACK:
			{
				pos[Y_] = idVar(part, bend_offset);
				if (self->subAssetId == ID_obj_model_shape)
					pos[Y_] -= sVar(position).Value(Y_);
				break;
			}
			case e_part_UPPER:
			case e_part_LOWER:
			{
				pos[Z_] = idVar(part, bend_offset);
				if (self->subAssetId == ID_obj_model_shape)
					pos[Z_] -= sVar(position).Value(Z_);
				break;
			}
		}
		
		MatrixType mat = matrix_build(pos.Value(X_), pos.Value(Y_), pos.Value(Z_), bend.Value(X_), bend.Value(Y_), bend.Value(Z_), sca.Value(X_), sca.Value(Y_), sca.Value(Z_));
		if (self->subAssetId == ID_obj_model_shape)
			mat = matrix_multiply(matrix_build(-pos.Value(X_), -pos.Value(Y_), -pos.Value(Z_), sVar(rotation).Value(X_), sVar(rotation).Value(Y_), sVar(rotation).Value(Z_), 1.0, 1.0, 1.0), mat);
		return mat;
	}
	
	VarType model_part_get_texture_material_name(VarType part, IntType map)
	{
		VarType key;
		if (part == null_)
			return DsMap(map).Value(/*""*/ STR(0));
		if (Obj(part)->subAssetId == ID_obj_model_part)
			key = idVar(part, name);
		else
			key = /*""*/ STR(0);
		
		if (!is_undefined(DsMap(map).Value(key)))
			return DsMap(map).Value(key);
		if (idVar(part, texture_material_name) != /*""*/ STR(0))
			return idVar(part, texture_material_name);
		return model_part_get_texture_material_name(idInt(part, texture_material_inherit), map);
	}
	
	VarType model_part_get_texture_name(VarType part, IntType map)
	{
		VarType key;
		if (part == null_)
			return DsMap(map).Value(/*""*/ STR(0));
		if (Obj(part)->subAssetId == ID_obj_model_part)
			key = idVar(part, name);
		else
			key = /*""*/ STR(0);
		
		if (!is_undefined(DsMap(map).Value(key)))
			return DsMap(map).Value(key);
		if (idVar(part, texture_name) != /*""*/ STR(0))
			return idVar(part, texture_name);
		return model_part_get_texture_name(idInt(part, texture_inherit), map);
	}
	
	VarType model_part_get_tex_normal_name(VarType part, IntType map)
	{
		VarType key;
		if (part == null_)
			return DsMap(map).Value(/*""*/ STR(0));
		if (Obj(part)->subAssetId == ID_obj_model_part)
			key = idVar(part, name);
		else
			key = /*""*/ STR(0);
		
		if (!is_undefined(DsMap(map).Value(key)))
			return DsMap(map).Value(key);
		if (idVar(part, texture_normal_name) != /*""*/ STR(0))
			return idVar(part, texture_normal_name);
		return model_part_get_tex_normal_name(idInt(part, texture_normal_inherit), map);
	}
	
	void model_shape_event_destroy(Scope<obj_model_shape> self)
	{
		if (self->vbuffer_default != null_)
			vbuffer_destroy(self->vbuffer_default);
	}
	
	VarType model_shape_generate_block(ScopeAny self, VecType bend)
	{
		RealType x1, x2, y1, y2, z1, z2, scalef;
		VecType size;
		x1 = sVar(from).Value(X_);
		y1 = sVar(from).Value(Y_);
		z1 = sVar(from).Value(Z_);
		x2 = sVar(to).Value(X_);
		y2 = sVar(to).Value(Y_);
		z2 = sVar(to).Value(Z_);
		size = point3D_sub(sVar(to), sVar(from));
		scalef = 0.005;
		BoolType isbent = !vec3_equals(bend, vec3(IntType(0))) && sVar(bend_shape) > 0;
		IntType segaxis = Z_;
		if (isbent)
		{
			if (sInt(bend_part) == e_part_LEFT || sInt(bend_part) == e_part_RIGHT)
				segaxis = X_;
			else
				if (sInt(bend_part) == e_part_BACK || sInt(bend_part) == e_part_FRONT)
					segaxis = Y_;
				else
					if (sInt(bend_part) == e_part_LOWER || sInt(bend_part) == e_part_UPPER)
						segaxis = Z_;
			
			
		}
		VecType texsize, texsizefix, texuv;
		texsize = point3D_sub(sVar(to_noscale), sVar(from_noscale));
		texsizefix = point3D_sub(texsize, vec3(1.0 / 256.0));
		texsize = vec3(texsize.Real(X_) / sVar(texture_size).Value(X_), texsize.Real(Y_) / sVar(texture_size).Value(Y_), texsize.Real(Z_) / sVar(texture_size).Value(Y_));
		texsizefix = vec3(texsizefix.Real(X_) / sVar(texture_size).Value(X_), texsizefix.Real(Y_) / sVar(texture_size).Value(Y_), texsizefix.Real(Z_) / sVar(texture_size).Value(Y_));
		texuv = vec2_div(sVar(uv), sVar(texture_size));
		VecType texeast1, texeast2, texeast3, texeast4;
		VecType texwest1, texwest2, texwest3, texwest4;
		VecType texsouth1, texsouth2, texsouth3, texsouth4;
		VecType texnorth1, texnorth2, texnorth3, texnorth4;
		VecType texstart1, texstart2, texstart3, texstart4;
		VecType texend1, texend2, texend3, texend4;
		VecType texup1, texup2, texup3, texup4;
		VecType texdown1, texdown2, texdown3, texdown4;
		texeast1 = point2D_add(texuv, point2D(texsize.Real(X_), IntType(0)));
		texeast2 = point2D_add(texeast1, point2D(texsizefix.Real(Y_), IntType(0)));
		texeast3 = point2D_add(texeast1, point2D(texsizefix.Real(Y_), texsizefix.Real(Z_)));
		texeast4 = point2D_add(texeast1, point2D(IntType(0), texsizefix.Real(Z_)));
		texwest1 = point2D_sub(texuv, point2D(texsize.Real(Y_), IntType(0)));
		texwest2 = point2D_add(texwest1, point2D(texsizefix.Real(Y_), IntType(0)));
		texwest3 = point2D_add(texwest1, point2D(texsizefix.Real(Y_), texsizefix.Real(Z_)));
		texwest4 = point2D_add(texwest1, point2D(IntType(0), texsizefix.Real(Z_)));
		texsouth1 = point2D_copy(texuv);
		texsouth2 = point2D_add(texsouth1, point2D(texsizefix.Real(X_), IntType(0)));
		texsouth3 = point2D_add(texsouth1, point2D(texsizefix.Real(X_), texsizefix.Real(Z_)));
		texsouth4 = point2D_add(texsouth1, point2D(IntType(0), texsizefix.Real(Z_)));
		texnorth1 = point2D_add(texeast1, point2D(texsize.Real(Y_), IntType(0)));
		texnorth2 = point2D_add(texnorth1, point2D(texsizefix.Real(X_), IntType(0)));
		texnorth3 = point2D_add(texnorth1, point2D(texsizefix.Real(X_), texsizefix.Real(Z_)));
		texnorth4 = point2D_add(texnorth1, point2D(IntType(0), texsizefix.Real(Z_)));
		texup1 = point2D_sub(texuv, point2D(IntType(0), texsize.Real(Y_)));
		texup2 = point2D_add(texup1, point2D(texsizefix.Real(X_), IntType(0)));
		texup3 = point2D_add(texup1, point2D(texsizefix.Real(X_), texsizefix.Real(Y_)));
		texup4 = point2D_add(texup1, point2D(IntType(0), texsizefix.Real(Y_)));
		texdown4 = point2D_add(texup1, point2D(texsize.Real(X_), IntType(0)));
		texdown3 = point2D_add(texdown4, point2D(texsizefix.Real(X_), IntType(0)));
		texdown2 = point2D_add(texdown4, point2D(texsizefix.Real(X_), texsizefix.Real(Y_)));
		texdown1 = point2D_add(texdown4, point2D(IntType(0), texsizefix.Real(Y_)));
		if (sVar(texture_mirror) > 0)
		{
			VecType tmp1, tmp2, tmp3, tmp4;
			tmp1 = texeast1;
			tmp2 = texeast2;
			tmp3 = texeast3;
			tmp4 = texeast4;
			texeast1 = texwest1;
			texeast2 = texwest2;
			texeast3 = texwest3;
			texeast4 = texwest4;
			texwest1 = tmp1;
			texwest2 = tmp2;
			texwest3 = tmp3;
			texwest4 = tmp4;
			tmp1 = texeast1;
			texeast1 = texeast2;
			texeast2 = tmp1;
			tmp1 = texeast3;
			texeast3 = texeast4;
			texeast4 = tmp1;
			tmp1 = texwest1;
			texwest1 = texwest2;
			texwest2 = tmp1;
			tmp1 = texwest3;
			texwest3 = texwest4;
			texwest4 = tmp1;
			tmp1 = texsouth1;
			texsouth1 = texsouth2;
			texsouth2 = tmp1;
			tmp1 = texsouth3;
			texsouth3 = texsouth4;
			texsouth4 = tmp1;
			tmp1 = texnorth1;
			texnorth1 = texnorth2;
			texnorth2 = tmp1;
			tmp1 = texnorth3;
			texnorth3 = texnorth4;
			texnorth4 = tmp1;
			tmp1 = texup1;
			texup1 = texup2;
			texup2 = tmp1;
			tmp1 = texup3;
			texup3 = texup4;
			texup4 = tmp1;
			tmp1 = texdown1;
			texdown1 = texdown2;
			texdown2 = tmp1;
			tmp1 = texdown3;
			texdown3 = texdown4;
			texdown4 = tmp1;
		}
		RealType sharpbend, detail, bendstart, bendend, bendsegsize;
		VarType bendsize;
		BoolType invangle;
		sharpbend = global::_app->project_bend_style == /*"blocky"*/ STR(1859) && sVar(bend_size) == null_ && ((sVec(bend_axis).Real(X_) && !sVec(bend_axis).Real(Y_) && !sVec(bend_axis).Real(Z_)) || (!sVec(bend_axis).Real(X_) && sVec(bend_axis).Real(Y_) && !sVec(bend_axis).Real(Z_)) || (!sVec(bend_axis).Real(X_) && !sVec(bend_axis).Real(Y_) && sVec(bend_axis).Real(Z_)));
		bendsize = (sVar(bend_size) == null_ ? VarType((global::_app->project_bend_style == /*"realistic"*/ STR(1860) ? 4.0 : 1.0)) : sVar(bend_size));
		detail = ((sharpbend > 0) ? IntType(2) : real(max({ bendsize, IntType(2) })));
		if ((sVar(bend_size) != null_ && sVar(bend_size) >= IntType(1)) && sVar(scale).Value(segaxis) > .5)
			detail /= sVar(scale).Value(segaxis);
		bendsegsize = (RealType)bendsize / detail;
		invangle = (sInt(bend_part) == e_part_LOWER || sInt(bend_part) == e_part_BACK || sInt(bend_part) == e_part_LEFT);
		VecType p1, p2, p3, p4;
		VarType n1, n2, n3, n4;
		RealType texp1, texp2, texp3;
		switch ((IntType)segaxis)
		{
			case X_:
			{
				bendstart = (sVar(bend_offset) - (sVar(position).Value(X_) + x1)) - (RealType)bendsize / 2.0;
				bendend = (sVar(bend_offset) - (sVar(position).Value(X_) + x1)) + (RealType)bendsize / 2.0;
				p1 = point3D(x1, y1, z2);
				p2 = point3D(x1, y2, z2);
				p3 = point3D(x1, y2, z1);
				p4 = point3D(x1, y1, z1);
				n1 = vec3(IntType(0), IntType(1), IntType(0));
				n2 = vec3(IntType(0), -IntType(1), IntType(0));
				n3 = vec3(IntType(0), IntType(0), IntType(1));
				n4 = vec3(IntType(0), IntType(0), -IntType(1));
				texp1 = texsouth1.Real(X_);
				texp2 = texnorth2.Real(X_);
				texp3 = texdown4.Real(X_);
				texstart1 = texwest1;
				texstart2 = texwest2;
				texstart3 = texwest3;
				texstart4 = texwest4;
				texend1 = texeast1;
				texend2 = texeast2;
				texend3 = texeast3;
				texend4 = texeast4;
				break;
			}
			
			case Y_:
			{
				bendstart = (sVar(bend_offset) - (sVar(position).Value(Y_) + y1)) - (RealType)bendsize / 2.0;
				bendend = (sVar(bend_offset) - (sVar(position).Value(Y_) + y1)) + (RealType)bendsize / 2.0;
				p1 = point3D(x2, y1, z2);
				p2 = point3D(x1, y1, z2);
				p3 = point3D(x1, y1, z1);
				p4 = point3D(x2, y1, z1);
				n1 = vec3(IntType(1), IntType(0), IntType(0));
				n2 = vec3(-IntType(1), IntType(0), IntType(0));
				n3 = vec3(IntType(0), IntType(0), IntType(1));
				n4 = vec3(IntType(0), IntType(0), -IntType(1));
				texp1 = texeast2.Real(X_);
				texp2 = texwest1.Real(X_);
				texp3 = texup1.Real(Y_);
				texstart1 = texnorth1;
				texstart2 = texnorth2;
				texstart3 = texnorth3;
				texstart4 = texnorth4;
				texend1 = texsouth1;
				texend2 = texsouth2;
				texend3 = texsouth3;
				texend4 = texsouth4;
				break;
			}
			
			case Z_:
			{
				bendstart = (sVar(bend_offset) - (sVar(position).Value(Z_) + z1)) - (RealType)bendsize / 2.0;
				bendend = (sVar(bend_offset) - (sVar(position).Value(Z_) + z1)) + (RealType)bendsize / 2.0;
				p1 = point3D(x1, y2, z1);
				p2 = point3D(x2, y2, z1);
				p3 = point3D(x2, y1, z1);
				p4 = point3D(x1, y1, z1);
				n1 = vec3(IntType(1), IntType(0), IntType(0));
				n2 = vec3(-IntType(1), IntType(0), IntType(0));
				n3 = vec3(IntType(0), IntType(1), IntType(0));
				n4 = vec3(IntType(0), -IntType(1), IntType(0));
				texp1 = texsouth3.Real(Y_);
				texstart1 = texdown1;
				texstart2 = texdown2;
				texstart3 = texdown3;
				texstart4 = texdown4;
				texend1 = texup1;
				texend2 = texup2;
				texend3 = texup3;
				texend4 = texup4;
				break;
			}
			
		}
		
		MatrixType mat;
		if (isbent)
		{
			RealType startp;
			VecType bendvec;
			if (bendstart > IntType(0))
				startp = IntType(0);
			else
				if (bendend < IntType(0))
					startp = IntType(1);
				else
					startp = (IntType(1) - bendend / bendsize);
			
			
			if (invangle)
				startp = IntType(1) - startp;
			bendvec = model_shape_get_bend(bend, startp);
			VecType startscale = vec3(IntType(0));
			if (sharpbend > 0)
				startscale = model_shape_get_bend_scale(self, bendstart, bendend, startp, true, IntType(0), bend);
			mat = model_part_get_bend_matrix(self, { self->id, bendvec, vec3(IntType(0)), vec3_add(vec3(IntType(1)), startscale) });
		}
		else
			mat = matrix_build(0.0, 0.0, 0.0, sVar(rotation).Value(X_), sVar(rotation).Value(Y_), sVar(rotation).Value(Z_), 1.0, 1.0, 1.0);
		
		p1 = point3D_mul_matrix(p1, mat);
		p2 = point3D_mul_matrix(p2, mat);
		p3 = point3D_mul_matrix(p3, mat);
		p4 = point3D_mul_matrix(p4, mat);
		n1 = vec3_normalize(vec3_mul_matrix(n1, mat));
		n2 = vec3_normalize(vec3_mul_matrix(n2, mat));
		n3 = vec3_normalize(vec3_mul_matrix(n3, mat));
		n4 = vec3_normalize(vec3_mul_matrix(n4, mat));
		vbuffer_start();
		global::vertex_emissive = sVar(color_emissive);
		global::vertex_wave = sInt(wind_wave);
		global::vertex_wave_zmin = sVar(wind_wave_zmin);
		global::vertex_wave_zmax = sVar(wind_wave_zmax);
		RealType segpos = IntType(0);
		while (true)
		{
			if (segpos == IntType(0))
			{
				vbuffer_add_triangle({ p1, p2, p3, texstart1, texstart2, texstart3, null_, null_, null_, sVar(invert) });
				vbuffer_add_triangle({ p3, p4, p1, texstart3, texstart4, texstart1, null_, null_, null_, sVar(invert) });
			}
			RealType segsize;
			if (!isbent || segpos >= bendend)
				segsize = size.Real(segaxis) - segpos;
			else
				if (segpos < bendstart)
					segsize = min({ size.Real(segaxis) - segpos, bendstart });
				else
				{
					segsize = bendsegsize;
					if (segpos == IntType(0))
						segsize -= mod((sVar(from).Value(segaxis) - bendstart), bendsegsize);
					segsize = min({ size.Real(segaxis) - segpos, segsize });
				}
			
			
			segpos += max({ segsize, 0.005 });
			if (segpos > size.Real(segaxis))
			{
				switch ((IntType)segaxis)
				{
					case X_:
					case Y_:
					{
						vbuffer_add_triangle({ p2, p1, p4, texend1, texend2, texend3, null_, null_, null_, sVar(invert) });
						vbuffer_add_triangle({ p4, p3, p2, texend3, texend4, texend1, null_, null_, null_, sVar(invert) });
						break;
					}
					
					case Z_:
					{
						vbuffer_add_triangle({ p4, p3, p2, texend1, texend2, texend3, null_, null_, null_, sVar(invert) });
						vbuffer_add_triangle({ p2, p1, p4, texend3, texend4, texend1, null_, null_, null_, sVar(invert) });
						break;
					}
					
				}
				
				break;
			}
			VecType np1, np2, np3, np4;
			VarType nn1, nn2, nn3, nn4;
			RealType ntexp1, ntexp2, ntexp3;
			switch ((IntType)segaxis)
			{
				case X_:
				{
					np1 = point3D(x1 + segpos, y1, z2);
					np2 = point3D(x1 + segpos, y2, z2);
					np3 = point3D(x1 + segpos, y2, z1);
					np4 = point3D(x1 + segpos, y1, z1);
					nn1 = vec3(IntType(0), IntType(1), IntType(0));
					nn2 = vec3(IntType(0), -IntType(1), IntType(0));
					nn3 = vec3(IntType(0), IntType(0), IntType(1));
					nn4 = vec3(IntType(0), IntType(0), -IntType(1));
					RealType toff = (segpos / size.Real(X_)) * texsizefix.Real(X_) * negate(sVar(texture_mirror));
					ntexp1 = texsouth1.Real(X_) + toff;
					ntexp2 = texnorth2.Real(X_) - toff;
					ntexp3 = texdown4.Real(X_) + toff;
					break;
				}
				
				case Y_:
				{
					np1 = point3D(x2, y1 + segpos, z2);
					np2 = point3D(x1, y1 + segpos, z2);
					np3 = point3D(x1, y1 + segpos, z1);
					np4 = point3D(x2, y1 + segpos, z1);
					nn1 = vec3(IntType(1), IntType(0), IntType(0));
					nn2 = vec3(-IntType(1), IntType(0), IntType(0));
					nn3 = vec3(IntType(0), IntType(0), IntType(1));
					nn4 = vec3(IntType(0), IntType(0), -IntType(1));
					RealType toff = (segpos / size.Real(Y_)) * texsizefix.Real(Y_);
					ntexp1 = texeast2.Real(X_) - toff * negate(sVar(texture_mirror));
					ntexp2 = texwest1.Real(X_) + toff * negate(sVar(texture_mirror));
					ntexp3 = texup1.Real(Y_) + toff;
					break;
				}
				
				case Z_:
				{
					np1 = point3D(x1, y2, z1 + segpos);
					np2 = point3D(x2, y2, z1 + segpos);
					np3 = point3D(x2, y1, z1 + segpos);
					np4 = point3D(x1, y1, z1 + segpos);
					nn1 = vec3(IntType(1), IntType(0), IntType(0));
					nn2 = vec3(-IntType(1), IntType(0), IntType(0));
					nn3 = vec3(IntType(0), IntType(1), IntType(0));
					nn4 = vec3(IntType(0), -IntType(1), IntType(0));
					RealType toff = (segpos / size.Real(Z_)) * texsizefix.Real(Z_);
					ntexp1 = texsouth3.Real(Y_) - toff;
					break;
				}
				
			}
			
			if (isbent)
			{
				RealType segp;
				VecType bendvec;
				if (segpos < bendstart)
					segp = IntType(0);
				else
					if (segpos >= bendend)
						segp = IntType(1);
					else
						segp = (IntType(1) - (bendend - segpos) / bendsize);
				
				
				if (invangle)
					segp = IntType(1) - segp;
				bendvec = model_shape_get_bend(bend, segp);
				VecType bendscale = vec3(IntType(0));
				if (sharpbend > 0)
				{
					bendscale = model_shape_get_bend_scale(self, bendstart, bendend, segp, false, segpos, bend);
					bendvec = vec3_mul(bend, segp);
				}
				mat = model_part_get_bend_matrix(self, { self->id, bendvec, vec3(IntType(0)), vec3_add(vec3_add(vec3(IntType(1)), bendscale), vec3(segp * scalef)) });
			}
			else
				mat = matrix_build(0.0, 0.0, 0.0, sVar(rotation).Value(X_), sVar(rotation).Value(Y_), sVar(rotation).Value(Z_), 1.0, 1.0, 1.0);
			
			np1 = point3D_mul_matrix(np1, mat);
			np2 = point3D_mul_matrix(np2, mat);
			np3 = point3D_mul_matrix(np3, mat);
			np4 = point3D_mul_matrix(np4, mat);
			if (sharpbend > 0)
			{
				n1 = null_;
				n2 = null_;
				n3 = null_;
				n4 = null_;
				nn1 = null_;
				nn2 = null_;
				nn3 = null_;
				nn4 = null_;
			}
			else
			{
				nn1 = vec3_normalize(vec3_mul_matrix(nn1, mat));
				nn2 = vec3_normalize(vec3_mul_matrix(nn2, mat));
				nn3 = vec3_normalize(vec3_mul_matrix(nn3, mat));
				nn4 = vec3_normalize(vec3_mul_matrix(nn4, mat));
			}
			
			VecType t1, t2, t3, t4;
			switch ((IntType)segaxis)
			{
				case X_:
				{
					t1 = vec2(texp1, texsouth1.Real(Y_));
					t2 = vec2(ntexp1, texsouth1.Real(Y_));
					t3 = vec2(ntexp1, texsouth3.Real(Y_));
					t4 = vec2(texp1, texsouth3.Real(Y_));
					vbuffer_add_triangle({ p2, np2, np3, t1, t2, t3, n1, nn1, nn1, sVar(invert) });
					vbuffer_add_triangle({ np3, p3, p2, t3, t4, t1, nn1, n1, n1, sVar(invert) });
					t1 = vec2(ntexp2, texnorth1.Real(Y_));
					t2 = vec2(texp2, texnorth1.Real(Y_));
					t3 = vec2(texp2, texnorth3.Real(Y_));
					t4 = vec2(ntexp2, texnorth3.Real(Y_));
					vbuffer_add_triangle({ np1, p1, p4, t1, t2, t3, nn2, n2, n2, sVar(invert) });
					vbuffer_add_triangle({ p4, np4, np1, t3, t4, t1, n2, nn2, nn2, sVar(invert) });
					t1 = vec2(texp1, texup1.Real(Y_));
					t2 = vec2(ntexp1, texup1.Real(Y_));
					t3 = vec2(ntexp1, texup3.Real(Y_));
					t4 = vec2(texp1, texup3.Real(Y_));
					vbuffer_add_triangle({ p1, np1, np2, t1, t2, t3, n3, nn3, nn3, sVar(invert) });
					vbuffer_add_triangle({ np2, p2, p1, t3, t4, t1, nn3, n3, n3, sVar(invert) });
					t1 = vec2(texp3, texdown1.Real(Y_));
					t2 = vec2(ntexp3, texdown1.Real(Y_));
					t3 = vec2(ntexp3, texdown3.Real(Y_));
					t4 = vec2(texp3, texdown3.Real(Y_));
					vbuffer_add_triangle({ p3, np3, np4, t1, t2, t3, n4, nn4, nn4, sVar(invert) });
					vbuffer_add_triangle({ np4, p4, p3, t3, t4, t1, nn4, n4, n4, sVar(invert) });
					texp1 = ntexp1;
					texp2 = ntexp2;
					texp3 = ntexp3;
					break;
				}
				
				case Y_:
				{
					t1 = vec2(ntexp1, texeast1.Real(Y_));
					t2 = vec2(texp1, texeast1.Real(Y_));
					t3 = vec2(texp1, texeast3.Real(Y_));
					t4 = vec2(ntexp1, texeast3.Real(Y_));
					vbuffer_add_triangle({ np1, p1, p4, t1, t2, t3, nn1, n1, n1, sVar(invert) });
					vbuffer_add_triangle({ p4, np4, np1, t3, t4, t1, n1, nn1, nn1, sVar(invert) });
					t1 = vec2(texp2, texwest1.Real(Y_));
					t2 = vec2(ntexp2, texwest1.Real(Y_));
					t3 = vec2(ntexp2, texwest3.Real(Y_));
					t4 = vec2(texp2, texwest3.Real(Y_));
					vbuffer_add_triangle({ p2, np2, np3, t1, t2, t3, n2, nn2, nn2, sVar(invert) });
					vbuffer_add_triangle({ np3, p3, p2, t3, t4, t1, nn2, n2, n2, sVar(invert) });
					t1 = vec2(texup1.Real(X_), texp3);
					t2 = vec2(texup2.Real(X_), texp3);
					t3 = vec2(texup2.Real(X_), ntexp3);
					t4 = vec2(texup1.Real(X_), ntexp3);
					vbuffer_add_triangle({ p2, p1, np1, t1, t2, t3, n3, n3, nn3, sVar(invert) });
					vbuffer_add_triangle({ np1, np2, p2, t3, t4, t1, nn3, nn3, n3, sVar(invert) });
					t1 = vec2(texdown1.Real(X_), ntexp3);
					t2 = vec2(texdown2.Real(X_), ntexp3);
					t3 = vec2(texdown2.Real(X_), texp3);
					t4 = vec2(texdown1.Real(X_), texp3);
					vbuffer_add_triangle({ np3, np4, p4, t1, t2, t3, nn4, nn4, n4, sVar(invert) });
					vbuffer_add_triangle({ p4, p3, np3, t3, t4, t1, n4, n4, nn4, sVar(invert) });
					texp1 = ntexp1;
					texp2 = ntexp2;
					texp3 = ntexp3;
					break;
				}
				
				case Z_:
				{
					t1 = vec2(texeast1.Real(X_), ntexp1);
					t2 = vec2(texeast2.Real(X_), ntexp1);
					t3 = vec2(texeast2.Real(X_), texp1);
					t4 = vec2(texeast1.Real(X_), texp1);
					vbuffer_add_triangle({ np2, np3, p3, t1, t2, t3, nn1, nn1, n1, sVar(invert) });
					vbuffer_add_triangle({ p3, p2, np2, t3, t4, t1, n1, n1, nn1, sVar(invert) });
					t1 = vec2(texwest1.Real(X_), ntexp1);
					t2 = vec2(texwest2.Real(X_), ntexp1);
					t3 = vec2(texwest2.Real(X_), texp1);
					t4 = vec2(texwest1.Real(X_), texp1);
					vbuffer_add_triangle({ np4, np1, p1, t1, t2, t3, nn2, nn2, n2, sVar(invert) });
					vbuffer_add_triangle({ p1, p4, np4, t3, t4, t1, n2, n2, nn2, sVar(invert) });
					t1 = vec2(texsouth1.Real(X_), ntexp1);
					t2 = vec2(texsouth2.Real(X_), ntexp1);
					t3 = vec2(texsouth2.Real(X_), texp1);
					t4 = vec2(texsouth1.Real(X_), texp1);
					vbuffer_add_triangle({ np1, np2, p2, t1, t2, t3, nn3, nn3, n3, sVar(invert) });
					vbuffer_add_triangle({ p2, p1, np1, t3, t4, t1, n3, n3, nn3, sVar(invert) });
					t1 = vec2(texnorth1.Real(X_), ntexp1);
					t2 = vec2(texnorth2.Real(X_), ntexp1);
					t3 = vec2(texnorth2.Real(X_), texp1);
					t4 = vec2(texnorth1.Real(X_), texp1);
					vbuffer_add_triangle({ np3, np4, p4, t1, t2, t3, nn4, nn4, n4, sVar(invert) });
					vbuffer_add_triangle({ p4, p3, np3, t3, t4, t1, n4, n4, nn4, sVar(invert) });
					texp1 = ntexp1;
					break;
				}
				
			}
			
			p1 = np1;
			p2 = np2;
			p3 = np3;
			p4 = np4;
			n1 = nn1;
			n2 = nn2;
			n3 = nn3;
			n4 = nn4;
		}
		
		global::vertex_emissive = IntType(0);
		global::vertex_wave = e_vertex_wave_NONE;
		global::vertex_wave_zmin = null_;
		global::vertex_wave_zmax = null_;
		return vbuffer_done();
	}
	
}
