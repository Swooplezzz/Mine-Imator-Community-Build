/*
	NOTE:
	This file was autogenerated by CppGen, changes may be overwritten and forever lost!
	Modify at your own risk!
	
	[ Generated on 2023.07.16 06:12:48 ]
*/

#include "Scripts.hpp"

namespace CppProject
{
	RealType block_generate_liquid(ScopeAny self, RealType waterlogged)
	{
		BoolType matchxp, matchxn, matchyp, matchyn, matchzp, matchzn;
		BoolType solidxp, solidxn, solidyp, solidyn, solidzp, solidzn;
		matchxp = (!sBool(build_edge_xp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z)) == sInt(block_current));
		matchxn = (!sBool(build_edge_xn) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z)) == sInt(block_current));
		matchyp = (!sBool(build_edge_yp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)) == sInt(block_current));
		matchyn = (!sBool(build_edge_yn) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)) == sInt(block_current));
		matchzp = (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z) + IntType(1)) == sInt(block_current));
		matchzn = (!sBool(build_edge_zn) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z) - IntType(1)) == sInt(block_current));
		solidxp = (sInt(block_face_min_depth_xp) == e_block_depth_DEPTH0 && sBool(block_face_full_xp));
		solidxn = (sInt(block_face_min_depth_xn) == e_block_depth_DEPTH0 && sBool(block_face_full_xn));
		solidyp = (sInt(block_face_min_depth_yp) == e_block_depth_DEPTH0 && sBool(block_face_full_yp));
		solidyn = (sInt(block_face_min_depth_yn) == e_block_depth_DEPTH0 && sBool(block_face_full_yn));
		solidzp = (sInt(block_face_min_depth_zp) == e_block_depth_DEPTH0 && sBool(block_face_full_zp));
		solidzn = (sInt(block_face_min_depth_zn) == e_block_depth_DEPTH0 && sBool(block_face_full_zn));
		matchxp = (matchxp || (!sBool(build_edge_xp) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z))));
		matchxn = (matchxn || (!sBool(build_edge_xn) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z))));
		matchyp = (matchyp || (!sBool(build_edge_yp) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z))));
		matchyn = (matchyn || (!sBool(build_edge_yn) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z))));
		matchzp = (matchzp || (!sBool(build_edge_zp) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z) + IntType(1))));
		matchzn = (matchzn || (!sBool(build_edge_zn) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z) - IntType(1))));
		if (global::_app->project_render_liquid_animation > 0)
		{
			IntType model;
			if (matchzp)
			{
				if (solidxp && !sBool(build_edge_xp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1)) != sInt(block_current))
				{
					solidxp = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1));
					if (model != null_)
						solidxp = (idInt(model, face_min_depth_xn) == e_block_depth_DEPTH0 && idBool(model, face_full_xn));
				}
				if (solidxn && !sBool(build_edge_xn) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1)) != sInt(block_current))
				{
					solidxn = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1));
					if (model != null_)
						solidxn = (idInt(model, face_min_depth_xp) == e_block_depth_DEPTH0 && idBool(model, face_full_xp));
				}
				if (solidyp && !sBool(build_edge_yp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) + IntType(1)) != sInt(block_current))
				{
					solidyp = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) + IntType(1));
					if (model != null_)
						solidyp = (idInt(model, face_min_depth_yn) == e_block_depth_DEPTH0 && idBool(model, face_full_yn));
				}
				if (solidyn && !sBool(build_edge_yn) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) + IntType(1)) != sInt(block_current))
				{
					solidyn = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) + IntType(1));
					if (model != null_)
						solidyn = (idInt(model, face_min_depth_yp) == e_block_depth_DEPTH0 && idBool(model, face_full_yp));
				}
			}
			if (matchzn)
			{
				if (solidxp && !sBool(build_edge_xp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z) - IntType(1)) != sInt(block_current))
				{
					solidxp = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z) - IntType(1));
					if (model != null_)
						solidxp = (idInt(model, face_min_depth_xn) == e_block_depth_DEPTH0 && idBool(model, face_full_xn));
				}
				if (solidxn && !sBool(build_edge_xn) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z) - IntType(1)) != sInt(block_current))
				{
					solidxn = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z) - IntType(1));
					if (model != null_)
						solidxn = (idInt(model, face_min_depth_xp) == e_block_depth_DEPTH0 && idBool(model, face_full_xp));
				}
				if (solidyp && !sBool(build_edge_yp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) - IntType(1)) != sInt(block_current))
				{
					solidyp = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) - IntType(1));
					if (model != null_)
						solidyp = (idInt(model, face_min_depth_yn) == e_block_depth_DEPTH0 && idBool(model, face_full_yn));
				}
				if (solidyn && !sBool(build_edge_yn) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) - IntType(1)) != sInt(block_current))
				{
					solidyn = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) - IntType(1));
					if (model != null_)
						solidyn = (idInt(model, face_min_depth_yp) == e_block_depth_DEPTH0 && idBool(model, face_full_yp));
				}
			}
		}
		if ((matchxp || solidxp) && (matchxn || solidxn) && (matchyp || solidyp) && (matchyn || solidyn) && matchzp && (matchzn || solidzn))
			return IntType(0);
		IntType slot, dep, vbuf;
		RealType sheetwidth, sheetheight;
		RealType slotstillposx, slotstillposy, slotstillsizex, slotstillsizey;
		RealType slotflowposx, slotflowposy, slotflowsizex, slotflowsizey;
		slot = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_liquid_slot_map).Value(idVar(sInt(block_current), name));
		dep = DsList(ObjType(obj_resource, global::mc_res)->block_sheet_ani_depth_list).Value(slot);
		if (idVar(sInt(block_current), name) == /*"water"*/ STR(808))
			vbuf = e_block_vbuffer_WATER;
		else
			vbuf = e_block_vbuffer_ANIMATED;
		
		sheetwidth = block_sheet_ani_width;
		sheetheight = block_sheet_ani_height;
		slotstillposx = (mod(slot, sheetwidth)) * block_size_;
		slotstillposy = ((IntType)(slot / sheetwidth)) * block_size_;
		slotstillsizex = 1.0 / (sheetwidth * block_size_);
		slotstillsizey = 1.0 / (sheetheight * block_size_);
		slot = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_liquid_slot_map).Value(/*"flowing_"*/ STR(809) + idVar(sInt(block_current), name));
		slotflowposx = (mod(slot, sheetwidth)) * block_size_;
		slotflowposy = ((IntType)(slot / sheetwidth)) * block_size_;
		slotflowsizex = 1.0 / (sheetwidth * block_size_);
		slotflowsizey = 1.0 / (sheetheight * block_size_);
		BoolType topflow;
		RealType topangle;
		topflow = true;
		topangle = IntType(0);
		RealType level = ((waterlogged > 0) ? IntType(0) : sReal(block_state_id_current));
		RealType corner0z, corner1z, corner2z, corner3z, minz, averagez;
		if (global::_app->project_render_liquid_animation > 0)
		{
			sInt(block_vertex_wave) = e_vertex_wave_Z_ONLY;
			if (matchzn)
				sInt(block_vertex_wave_zmin) = null_;
			else
				sInt(block_vertex_wave_zmin) = sInt(block_pos_z);
			
		}
		sVar(block_vertex_rgb) = c_white;
		sReal(block_vertex_alpha) = IntType(1);
		if ((IntType)(level / IntType(8)) || matchzp)
		{
			corner0z = block_size_;
			corner1z = block_size_;
			corner2z = block_size_;
			corner3z = block_size_;
			minz = block_size_;
			averagez = block_size_;
			topflow = false;
		}
		else
		{
			RealType sidelevelxp, sidelevelxn, sidelevelyp, sidelevelyn;
			sidelevelxp = level;
			sidelevelxn = level;
			sidelevelyp = level;
			sidelevelyn = level;
			RealType corner0level, corner1level, corner2level, corner3level;
			corner0level = level;
			corner1level = level;
			corner2level = level;
			corner3level = level;
			if (!(waterlogged > 0))
			{
				if (!sBool(build_edge_xp) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						sidelevelxp = IntType(8);
					else
						if (matchxp)
							sidelevelxp = builder_get_state_id(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_xn) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						sidelevelxn = IntType(8);
					else
						if (matchxn)
							sidelevelxn = builder_get_state_id(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_yp) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						sidelevelyp = IntType(8);
					else
						if (matchyp)
							sidelevelyp = builder_get_state_id(self, sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_yn) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						sidelevelyn = IntType(8);
					else
						if (matchyn)
							sidelevelyn = builder_get_state_id(self, sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_xn) && !sBool(build_edge_yn) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						corner0level = IntType(8);
					else
						if (builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)) == sInt(block_current))
							corner0level = builder_get_state_id(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_xp) && !sBool(build_edge_yn) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						corner1level = IntType(8);
					else
						if (builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)) == sInt(block_current))
							corner1level = builder_get_state_id(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_xp) && !sBool(build_edge_yp) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						corner2level = IntType(8);
					else
						if (builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)) == sInt(block_current))
							corner2level = builder_get_state_id(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_xn) && !sBool(build_edge_yp) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						corner3level = IntType(8);
					else
						if (builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)) == sInt(block_current))
							corner3level = builder_get_state_id(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z));
					
				}
			}
			IntType flowxp, flowxn, flowyp, flowyn;
			flowxp = IntType(0);
			flowxn = IntType(0);
			flowyp = IntType(0);
			flowyn = IntType(0);
			if (mod(sidelevelxp, IntType(8)) < level)
				flowxn++;
			else
				if (mod(sidelevelxp, IntType(8)) > level)
					flowxp++;
			
			if (mod(sidelevelxn, IntType(8)) < level)
				flowxp++;
			else
				if (mod(sidelevelxn, IntType(8)) > level)
					flowxn++;
			
			if (mod(sidelevelyp, IntType(8)) < level)
				flowyn++;
			else
				if (mod(sidelevelyp, IntType(8)) > level)
					flowyp++;
			
			if (mod(sidelevelyn, IntType(8)) < level)
				flowyp++;
			else
				if (mod(sidelevelyn, IntType(8)) > level)
					flowyn++;
			
			RealType myz, sidezxp, sidezxn, sidezyp, sidezyn;
			myz = IntType(14) - (level / 7.0) * 13.5;
			sidezxp = (((IntType)(sidelevelxp / IntType(8))) ? block_size_ : (IntType(14) - ((sidelevelxp / 7.0) * 13.5)));
			sidezxn = (((IntType)(sidelevelxn / IntType(8))) ? block_size_ : (IntType(14) - ((sidelevelxn / 7.0) * 13.5)));
			sidezyp = (((IntType)(sidelevelyp / IntType(8))) ? block_size_ : (IntType(14) - ((sidelevelyp / 7.0) * 13.5)));
			sidezyn = (((IntType)(sidelevelyn / IntType(8))) ? block_size_ : (IntType(14) - ((sidelevelyn / 7.0) * 13.5)));
			corner0z = (((IntType)(corner0level / IntType(8))) ? block_size_ : (IntType(14) - ((corner0level / 7.0) * 13.5)));
			corner1z = (((IntType)(corner1level / IntType(8))) ? block_size_ : (IntType(14) - ((corner1level / 7.0) * 13.5)));
			corner2z = (((IntType)(corner2level / IntType(8))) ? block_size_ : (IntType(14) - ((corner2level / 7.0) * 13.5)));
			corner3z = (((IntType)(corner3level / IntType(8))) ? block_size_ : (IntType(14) - ((corner3level / 7.0) * 13.5)));
			corner0z = max({ corner0z, sidezxn, sidezyn, myz });
			corner1z = max({ corner1z, sidezxp, sidezyn, myz });
			corner2z = max({ corner2z, sidezxp, sidezyp, myz });
			corner3z = max({ corner3z, sidezxn, sidezyp, myz });
			averagez = (corner0z + corner1z + corner2z + corner3z) / 4.0;
			minz = min({ corner0z, corner1z, corner2z, corner3z });
			if ((!(flowxn > 0) && !(flowxp > 0) && !(flowyn > 0) && !(flowyp > 0)) || (flowxn > 0 && flowxp > 0 && flowyn > 0 && flowyp > 0) || (flowxn > 0 && flowxp > 0 && !(flowyn > 0) && !(flowyp > 0)) || (!(flowxn > 0) && !(flowxp > 0) && flowyn > 0 && flowyp > 0))
				topflow = false;
			else
				if (flowxn > 0 && flowxp > 0 && flowyp > 0)
					topangle = IntType(0);
				else
					if (flowxn > 0 && flowxp > 0 && flowyn > 0)
						topangle = IntType(180);
					else
						if (flowxp > 0 && flowyn > 0 && flowyp > 0)
							topangle = IntType(90);
						else
							if (flowxn > 0 && flowyn > 0 && flowyp > 0)
								topangle = IntType(270);
							else
								if (flowxn > 0 && flowyn > 0)
									topangle = IntType(180) + IntType(45) + IntType(10) * (flowxn - IntType(1)) - IntType(10) * (flowyn - IntType(1));
								else
									if (flowxp > 0 && flowyn > 0)
										topangle = IntType(180) - IntType(45) + IntType(10) * (flowyn - IntType(1)) - IntType(10) * (flowxp - IntType(1));
									else
										if (flowxn > 0 && flowyp > 0)
											topangle = IntType(270) + IntType(45) + IntType(10) * (flowyp - IntType(1)) - IntType(10) * (flowxn - IntType(1));
										else
											if (flowxp > 0 && flowyp > 0)
												topangle = IntType(45) + IntType(10) * (flowxp - IntType(1)) - IntType(10) * (flowyp - IntType(1));
											else
												if (flowyp > 0)
													topangle = IntType(0);
												else
													if (flowxp > 0)
														topangle = IntType(90);
													else
														if (flowyn > 0)
															topangle = IntType(180);
														else
															if (flowxn > 0)
																topangle = IntType(270);
													
												
											
										
									
								
							
						
					
				
			
			
		}
		
		RealType sidetex0x, sidetex0y, sidetex1x, sidetex1y, sidetex2x, sidetex2y, sidetex3x, sidetex3y;
		RealType cornerlefttex0x, cornerlefttex0y, cornerlefttex1x, cornerlefttex1y, cornerlefttex2x, cornerlefttex2y, cornerlefttex3x, cornerlefttex3y;
		RealType cornerrighttex0x, cornerrighttex0y, cornerrighttex1x, cornerrighttex1y, cornerrighttex2x, cornerrighttex2y, cornerrighttex3x, cornerrighttex3y;
		RealType toptex0x, toptex0y, toptex1x, toptex1y, toptex2x, toptex2y, toptex3x, toptex3y;
		RealType topmidtexx, topmidtexy;
		sidetex0x = IntType(0);
		sidetex0y = block_size_ - minz;
		sidetex1x = block_size_;
		sidetex1y = block_size_ - minz;
		sidetex2x = block_size_;
		sidetex2y = block_size_;
		sidetex3x = IntType(0);
		sidetex3y = block_size_;
		cornerlefttex0x = IntType(0);
		cornerlefttex0y = block_size_ - corner0z;
		cornerlefttex1x = IntType(0);
		cornerlefttex1y = block_size_ - corner1z;
		cornerlefttex2x = IntType(0);
		cornerlefttex2y = block_size_ - corner2z;
		cornerlefttex3x = IntType(0);
		cornerlefttex3y = block_size_ - corner3z;
		cornerrighttex0x = block_size_;
		cornerrighttex0y = block_size_ - corner0z;
		cornerrighttex1x = block_size_;
		cornerrighttex1y = block_size_ - corner1z;
		cornerrighttex2x = block_size_;
		cornerrighttex2y = block_size_ - corner2z;
		cornerrighttex3x = block_size_;
		cornerrighttex3y = block_size_ - corner3z;
		if (topangle != IntType(0))
		{
			RealType p = (mod_fix(topangle, IntType(90)) / 90.0) * block_size_;
			toptex0x = p;
			toptex0y = IntType(0);
			toptex1x = block_size_;
			toptex1y = p;
			toptex2x = block_size_ - p;
			toptex2y = block_size_;
			toptex3x = IntType(0);
			toptex3y = block_size_ - p;
			for (IntType _it = 0, _it_max = (IntType)(topangle / IntType(90)); _it < _it_max; _it++)
			{
				RealType tmpx, tmpy;
				tmpx = toptex0x;
				tmpy = toptex0y;
				toptex0x = toptex1x;
				toptex0y = toptex1y;
				toptex1x = toptex2x;
				toptex1y = toptex2y;
				toptex2x = toptex3x;
				toptex2y = toptex3y;
				toptex3x = tmpx;
				toptex3y = tmpy;
			}
		}
		else
		{
			toptex0x = IntType(0);
			toptex0y = IntType(0);
			toptex1x = block_size_;
			toptex1y = IntType(0);
			toptex2x = block_size_;
			toptex2y = block_size_;
			toptex3x = IntType(0);
			toptex3y = block_size_;
		}
		
		topmidtexx = block_size_ / 2.0;
		topmidtexy = block_size_ / 2.0;
		sidetex0x = (sidetex0x + slotflowposx) * slotflowsizex;
		sidetex0y = (sidetex0y + slotflowposy) * slotflowsizey;
		sidetex1x = (sidetex1x + slotflowposx) * slotflowsizex;
		sidetex1y = (sidetex1y + slotflowposy) * slotflowsizey;
		sidetex2x = (sidetex2x + slotflowposx) * slotflowsizex;
		sidetex2y = (sidetex2y + slotflowposy) * slotflowsizey;
		sidetex3x = (sidetex3x + slotflowposx) * slotflowsizex;
		sidetex3y = (sidetex3y + slotflowposy) * slotflowsizey;
		cornerlefttex0x = (cornerlefttex0x + slotflowposx) * slotflowsizex;
		cornerlefttex0y = (cornerlefttex0y + slotflowposy) * slotflowsizey;
		cornerlefttex1x = (cornerlefttex1x + slotflowposx) * slotflowsizex;
		cornerlefttex1y = (cornerlefttex1y + slotflowposy) * slotflowsizey;
		cornerlefttex2x = (cornerlefttex2x + slotflowposx) * slotflowsizex;
		cornerlefttex2y = (cornerlefttex2y + slotflowposy) * slotflowsizey;
		cornerlefttex3x = (cornerlefttex3x + slotflowposx) * slotflowsizex;
		cornerlefttex3y = (cornerlefttex3y + slotflowposy) * slotflowsizey;
		cornerrighttex0x = (cornerrighttex0x + slotflowposx) * slotflowsizex;
		cornerrighttex0y = (cornerrighttex0y + slotflowposy) * slotflowsizey;
		cornerrighttex1x = (cornerrighttex1x + slotflowposx) * slotflowsizex;
		cornerrighttex1y = (cornerrighttex1y + slotflowposy) * slotflowsizey;
		cornerrighttex2x = (cornerrighttex2x + slotflowposx) * slotflowsizex;
		cornerrighttex2y = (cornerrighttex2y + slotflowposy) * slotflowsizey;
		cornerrighttex3x = (cornerrighttex3x + slotflowposx) * slotflowsizex;
		cornerrighttex3y = (cornerrighttex3y + slotflowposy) * slotflowsizey;
		if (topflow)
		{
			toptex0x = (toptex0x + slotflowposx) * slotflowsizex;
			toptex0y = (toptex0y + slotflowposy) * slotflowsizey;
			toptex1x = (toptex1x + slotflowposx) * slotflowsizex;
			toptex1y = (toptex1y + slotflowposy) * slotflowsizey;
			toptex2x = (toptex2x + slotflowposx) * slotflowsizex;
			toptex2y = (toptex2y + slotflowposy) * slotflowsizey;
			toptex3x = (toptex3x + slotflowposx) * slotflowsizex;
			toptex3y = (toptex3y + slotflowposy) * slotflowsizey;
			topmidtexx = (topmidtexx + slotflowposx) * slotflowsizex;
			topmidtexy = (topmidtexy + slotflowposy) * slotflowsizey;
		}
		else
		{
			toptex0x = (toptex0x + slotstillposx) * slotstillsizex;
			toptex0y = (toptex0y + slotstillposy) * slotstillsizey;
			toptex1x = (toptex1x + slotstillposx) * slotstillsizex;
			toptex1y = (toptex1y + slotstillposy) * slotstillsizey;
			toptex2x = (toptex2x + slotstillposx) * slotstillsizex;
			toptex2y = (toptex2y + slotstillposy) * slotstillsizey;
			toptex3x = (toptex3x + slotstillposx) * slotstillsizex;
			toptex3y = (toptex3y + slotstillposy) * slotstillsizey;
			topmidtexx = (topmidtexx + slotstillposx) * slotstillsizex;
			topmidtexy = (topmidtexy + slotstillposy) * slotstillsizey;
		}
		
		RealType x1, x2, y1, y2, z1, z2;
		RealType midx, midy, midz;
		x1 = sInt(block_pos_x);
		y1 = sInt(block_pos_y);
		z1 = floor(sInt(block_pos_z));
		x2 = x1 + block_size_;
		y2 = y1 + block_size_;
		z2 = z1 + minz;
		midx = x1 + block_size_ / 2.0;
		midy = y1 + block_size_ / 2.0;
		midz = z1 + averagez;
		if (waterlogged > 0)
		{
			RealType indent = 0.05;
			if (!matchxp)
				x2 -= indent;
			if (!matchxn)
				x1 += indent;
			if (!matchyp)
				y2 -= indent;
			if (!matchyn)
				y1 += indent;
		}
		corner0z += z1;
		corner1z += z1;
		corner2z += z1;
		corner3z += z1;
		sVar(block_vbuffer_current) = ObjType(obj_builder, global::mc_builder)->vbuffer[dep][vbuf];
		sVar(block_vertex_emissive) = idVar(sInt(block_current), emissive);
		if (!matchxp && !solidxp)
		{
			builder_add_face(Scope<obj_builder_thread>(self), x2, y2, z2, x2, y1, z2, x2, y1, z1, x2, y2, z1, sidetex0x, sidetex0y, sidetex1x, sidetex1y, sidetex2x, sidetex2y, sidetex3x, sidetex3y, null_);
			if (corner1z > corner2z)
				builder_add_triangle(Scope<obj_builder_thread>(self), x2, y1, z2, x2, y2, z2, x2, y1, corner1z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerrighttex1x, cornerrighttex1y, null_);
			else
				builder_add_triangle(Scope<obj_builder_thread>(self), x2, y1, z2, x2, y2, z2, x2, y2, corner2z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerlefttex2x, cornerlefttex2y, null_);
			
		}
		if (!matchxn && !solidxn)
		{
			builder_add_face(Scope<obj_builder_thread>(self), x1, y1, z2, x1, y2, z2, x1, y2, z1, x1, y1, z1, sidetex0x, sidetex0y, sidetex1x, sidetex1y, sidetex2x, sidetex2y, sidetex3x, sidetex3y, null_);
			if (corner3z > corner0z)
				builder_add_triangle(Scope<obj_builder_thread>(self), x1, y2, z2, x1, y1, z2, x1, y2, corner3z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerrighttex3x, cornerrighttex3y, null_);
			else
				builder_add_triangle(Scope<obj_builder_thread>(self), x1, y2, z2, x1, y1, z2, x1, y1, corner0z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerlefttex0x, cornerlefttex0y, null_);
			
		}
		if (!matchyp && !solidyp)
		{
			builder_add_face(Scope<obj_builder_thread>(self), x1, y2, z2, x2, y2, z2, x2, y2, z1, x1, y2, z1, sidetex0x, sidetex0y, sidetex1x, sidetex1y, sidetex2x, sidetex2y, sidetex3x, sidetex3y, null_);
			if (corner2z > corner3z)
				builder_add_triangle(Scope<obj_builder_thread>(self), x2, y2, z2, x1, y2, z2, x2, y2, corner2z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerrighttex2x, cornerrighttex2y, null_);
			else
				builder_add_triangle(Scope<obj_builder_thread>(self), x2, y2, z2, x1, y2, z2, x1, y2, corner3z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerlefttex3x, cornerlefttex3y, null_);
			
		}
		if (!matchyn && !solidyn)
		{
			builder_add_face(Scope<obj_builder_thread>(self), x2, y1, z2, x1, y1, z2, x1, y1, z1, x2, y1, z1, sidetex0x, sidetex0y, sidetex1x, sidetex1y, sidetex2x, sidetex2y, sidetex3x, sidetex3y, null_);
			if (corner0z > corner1z)
				builder_add_triangle(Scope<obj_builder_thread>(self), x1, y1, z2, x2, y1, z2, x1, y1, corner0z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerrighttex0x, cornerrighttex0y, null_);
			else
				builder_add_triangle(Scope<obj_builder_thread>(self), x1, y1, z2, x2, y1, z2, x2, y1, corner1z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerlefttex1x, cornerlefttex1y, null_);
			
		}
		if (!matchzp)
		{
			builder_add_triangle(Scope<obj_builder_thread>(self), midx, midy, midz, x1, y1, corner0z, x2, y1, corner1z, topmidtexx, topmidtexy, toptex0x, toptex0y, toptex1x, toptex1y, null_);
			builder_add_triangle(Scope<obj_builder_thread>(self), midx, midy, midz, x2, y1, corner1z, x2, y2, corner2z, topmidtexx, topmidtexy, toptex1x, toptex1y, toptex2x, toptex2y, null_);
			builder_add_triangle(Scope<obj_builder_thread>(self), midx, midy, midz, x2, y2, corner2z, x1, y2, corner3z, topmidtexx, topmidtexy, toptex2x, toptex2y, toptex3x, toptex3y, null_);
			builder_add_triangle(Scope<obj_builder_thread>(self), midx, midy, midz, x1, y2, corner3z, x1, y1, corner0z, topmidtexx, topmidtexy, toptex3x, toptex3y, toptex0x, toptex0y, null_);
		}
		if (!matchzn && !solidzn)
			builder_add_face(Scope<obj_builder_thread>(self), x1, y2, z1, x2, y2, z1, x2, y1, z1, x1, y1, z1, toptex3x, toptex3y, toptex2x, toptex2y, toptex1x, toptex1y, toptex0x, toptex0y, null_);
		sVar(block_vertex_rgb) = c_white;
		sReal(block_vertex_alpha) = IntType(1);
		return 0.0;
	}
	
	RealType block_get_state_id(VarType block, VarType vars)
	{
		IntType varslen = array_length(VarType::CreateRef(vars));
		if (varslen == IntType(0) || ObjType(obj_block, block)->states_map == null_)
			return IntType(0);
		RealType sid = IntType(0);
		for (IntType i = IntType(0); i < varslen; i += IntType(2))
		{
			VarType statename, valname, state, valid;
			statename = vars.Value(i);
			valname = vars.Value(i + IntType(1));
			if (statename == /*"id"*/ STR(82))
				continue;
			state = DsMap(ObjType(obj_block, block)->states_map).Value(statename);
			if (is_undefined(state))
				continue;
			valid = DsMap(idInt(state, value_map)).Value(valname);
			if (is_undefined(valid))
				continue;
			sid += idReal(state, value_id) * valid;
		}
		return sid;
	}
	
	ArrType block_get_state_id_state_vars(VarType block, VarType stateid)
	{
		ArrType vars = ArrType();
		if (idInt(block, states_map) != null_)
		{
			VarType key;
			IntType i;
			key = ds_map_find_first(idInt(block, states_map));
			i = IntType(0);
			while (!is_undefined(key))
			{
				vars[i * IntType(2)] = idVar(DsMap(idInt(block, states_map)).Value(key), name);
				vars[i * IntType(2) + IntType(1)] = block_get_state_id_value(block, stateid, idVar(DsMap(idInt(block, states_map)).Value(key), name));
				key = ds_map_find_next(idInt(block, states_map), key);
				i++;
			}
			
		}
		return vars;
	}
	
	VarType block_get_state_id_value(VarType block, VarType stateid, VarType name)
	{
		VarType state;
		if (block == null_ || idInt(block, states_map) == null_)
			return VarType();
		state = DsMap(idInt(block, states_map)).Value(name);
		if (is_undefined(state))
			return VarType();
		return idVar(state, value_name).Value(mod(((IntType)(stateid / idReal(state, value_id))), idReal(state, value_amount)));
	}
	
	IntType block_get_timeline(Scope<obj_builder_thread> self, VarType block, VarType stateid)
	{
		IntType pos = self->build_pos;
		withOne (obj_block_tl, (new obj_block_tl)->id, self->id)
		{
			ObjType(obj_block_tl, self->id)->block = block;
			self->model_name = idVar(block, tl_model_name);
			self->model_state = ArrType();
			if (self->model_name != /*""*/ STR(0))
			{
				if (!idBool(block, tl_has_model_state))
					self->model_state = block_get_state_id_state_vars(block, stateid);
				else
					if (idInt(block, tl_model_state_amount) == IntType(0))
						self->model_state = array_copy_1d(idVar(block, tl_model_state));
				
				for (IntType i = IntType(0); i < idInt(block, tl_model_state_amount); i++)
				{
					VarType curstate = idVar(block, tl_model_state).Value(i);
					if (array_contains(ObjType(obj_block_tl_state, curstate)->state_id, stateid))
					{
						self->model_state = array_copy_1d(ObjType(obj_block_tl_state, curstate)->value);
						break;
					}
				}
			}
			self->has_text = idVar(block, tl_has_text);
			if (self->has_text > 0)
			{
				self->text = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_map).Value(pos);
				self->text_color = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_color_map).Value(pos);
				self->text_emissive = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_glowing_map).Value(pos);
				if (is_undefined(self->text))
				{
					self->text = /*""*/ STR(0);
					self->text_color = c_black;
					self->text_emissive = IntType(0);
				}
				self->text_position = idVar(block, tl_text_position);
				self->text_scale = idVar(block, tl_text_scale);
			}
			self->pattern_type = idVar(block, tl_pattern_type);
			if (self->pattern_type != /*""*/ STR(0))
			{
				self->banner_color = DsMap(ObjType(obj_builder, global::mc_builder)->block_banner_color_map).Value(pos);
				self->banner_patterns = DsMap(ObjType(obj_builder, global::mc_builder)->block_banner_patterns_map).Value(pos);
				self->banner_pattern_colors = DsMap(ObjType(obj_builder, global::mc_builder)->block_banner_pattern_colors_map).Value(pos);
				if (is_undefined(self->banner_color))
				{
					self->banner_color = c_white;
					self->banner_patterns = ArrType();
					self->banner_pattern_colors = ArrType();
				}
			}
			if (DsMap(ObjType(obj_builder, global::mc_builder)->block_skull_map).Value(pos) != VarType())
			{
				VarType userid = DsMap(ObjType(obj_builder, global::mc_builder)->block_skull_map).Value(pos);
				self->texture = DsMap(ObjType(obj_builder, global::mc_builder)->block_skull_res_map).Value(userid);
			}
			else
				self->texture = null_;
			
			self->rot_point = idVar(block, tl_rot_point);
			self->position = idVar(block, tl_position);
			self->rotation = idVar(block, tl_rotation);
			for (IntType i = IntType(0); i < idInt(block, tl_rot_point_state_amount); i++)
			{
				VarType curstate = idArr(block, tl_rot_point_state).Value(i);
				if (array_contains(ObjType(obj_block_tl_state, curstate)->state_id, stateid))
				{
					self->rot_point = ObjType(obj_block_tl_state, curstate)->value;
					break;
				}
			}
			for (IntType i = IntType(0); i < idInt(block, tl_position_state_amount); i++)
			{
				VarType curstate = idArr(block, tl_position_state).Value(i);
				if (array_contains(ObjType(obj_block_tl_state, curstate)->state_id, stateid))
				{
					self->position = ObjType(obj_block_tl_state, curstate)->value;
					break;
				}
			}
			for (IntType i = IntType(0); i < idInt(block, tl_rotation_state_amount); i++)
			{
				VarType curstate = idArr(block, tl_rotation_state).Value(i);
				if (array_contains(ObjType(obj_block_tl_state, curstate)->state_id, stateid))
				{
					self->rotation = ObjType(obj_block_tl_state, curstate)->value;
					break;
				}
			}
			self->position[X_] += ObjType(obj_builder_thread, self.otherId)->build_pos_x * block_size_;
			self->position[Y_] += ObjType(obj_builder_thread, self.otherId)->build_pos_y * block_size_;
			self->position[Z_] += ObjType(obj_builder_thread, self.otherId)->build_pos_z * block_size_;
			self->variant = block_get_state_id_value(block, stateid, /*"variant"*/ STR(806));
			return self->id;
		}
		
		return IntType(0);
	}
	
	IntType block_load(VarType map, IntType typemap)
	{
		withOne (obj_block, (new obj_block)->id, noone)
		{
			self->block_id = array_length(VarType::CreateRef(global::block_objs));
			array_add(VarType::CreateRef(global::block_objs), self->id);
			if (is_string(DsMap(map).Value(/*"name"*/ STR(810))))
				self->name = DsMap(map).Value(/*"name"*/ STR(810));
			else
			{
				log({ /*"Missing parameter \"name\""*/ STR(811) });
				return null_;
			}
			
			if (dev_mode_debug_names && !text_exists(/*"block"*/ STR(531) + self->name))
				log({ /*"block/"*/ STR(812) + self->name + dev_mode_name_translation_message });
			if (is_string(DsMap(map).Value(/*"type"*/ STR(796))))
			{
				self->type = DsMap(map).Value(/*"type"*/ STR(796));
				self->set_script = asset_get_index(/*"block_set_"*/ STR(813) + self->type);
				self->generate_script = asset_get_index(/*"block_generate_"*/ STR(814) + self->type);
			}
			else
			{
				self->type = /*""*/ STR(0);
				self->set_script = null_;
				self->generate_script = null_;
			}
			
			if (is_string(DsMap(map).Value(/*"file"*/ STR(115))))
				self->filename = DsMap(map).Value(/*"file"*/ STR(115));
			else
				self->filename = /*""*/ STR(0);
			
			if (is_real(DsMap(map).Value(/*"emissive"*/ STR(815))))
				self->emissive = DsMap(map).Value(/*"emissive"*/ STR(815));
			else
				self->emissive = IntType(0);
			
			if (is_bool(DsMap(map).Value(/*"random_offset"*/ STR(816))))
				self->random_offset = DsMap(map).Value(/*"random_offset"*/ STR(816));
			else
				self->random_offset = false;
			
			if (is_bool(DsMap(map).Value(/*"random_offset_xz"*/ STR(817))))
				self->random_offset_xy = DsMap(map).Value(/*"random_offset_xz"*/ STR(817));
			else
				self->random_offset_xy = false;
			
			self->states_map = null_;
			self->state_id_amount = IntType(1);
			if (ds_map_valid(DsMap(map).Value(/*"states"*/ STR(818))))
			{
				self->states_map = ds_map_create();
				VarType curstate;
				IntType num;
				curstate = ds_map_find_first((IntType)(DsMap(map).Value(/*"states"*/ STR(818))));
				num = IntType(0);
				while (!is_undefined(curstate))
				{
					if (dev_mode_debug_names && !text_exists(/*"blockstate"*/ STR(786) + curstate))
						log({ /*"block/state/"*/ STR(819) + curstate + dev_mode_name_translation_message });
					withOne (obj_block_state, (new obj_block_state)->id, self->id)
					{
						self->name = curstate;
						IntType valuelist = ds_map_find_value((IntType)(DsMap(map).Value(/*"states"*/ STR(818))), curstate);
						self->value_amount = ds_list_size(valuelist);
						self->value_map = ds_map_create();
						ObjType(obj_block_state, self->id)->num = num++;
						self->value_id = ObjType(obj_block, self.otherId)->state_id_amount;
						ObjType(obj_block, self.otherId)->state_id_amount *= self->value_amount;
						for (IntType v = IntType(0); v < self->value_amount; v++)
						{
							VarType curvalue = DsList(valuelist).Value(v);
							self->value_name[v] = curvalue;
							self->value_filename[v] = /*""*/ STR(0);
							self->value_file[v] = null_;
							self->value_emissive[v] = null_;
							self->value_random_offset[v] = null_;
							self->value_random_offset_xy[v] = null_;
							if (ds_map_valid(curvalue))
							{
								self->value_name[v] = DsMap(curvalue).Value(/*"value"*/ STR(820));
								if (is_string(DsMap(curvalue).Value(/*"file"*/ STR(115))))
									self->value_filename[v] = DsMap(curvalue).Value(/*"file"*/ STR(115));
								if (is_real(DsMap(curvalue).Value(/*"emissive"*/ STR(815))))
									self->value_emissive[v] = DsMap(curvalue).Value(/*"emissive"*/ STR(815));
								if (is_bool(DsMap(curvalue).Value(/*"random_offset"*/ STR(816))))
									self->value_random_offset[v] = DsMap(curvalue).Value(/*"random_offset"*/ STR(816));
								if (is_bool(DsMap(curvalue).Value(/*"random_offset_xz"*/ STR(817))))
									self->value_random_offset_xy[v] = DsMap(curvalue).Value(/*"random_offset_xz"*/ STR(817));
							}
							DsMap(self->value_map)[self->value_name.Value(v)] = v;
							if (dev_mode_debug_names && string_length(self->value_name.Value(v)) > IntType(3) && !text_exists(/*"blockstatevalue"*/ STR(787) + self->value_name.Value(v)))
								log({ /*"block/state/value/"*/ STR(821) + self->value_name.Value(v) + dev_mode_name_translation_message });
						}
						DsMap(ObjType(obj_block, self.otherId)->states_map)[curstate] = self->id;
						curstate = ds_map_find_next((IntType)(DsMap(map).Value(/*"states"*/ STR(818))), curstate);
					}
					
				}
				
			}
			if (self->filename != /*""*/ STR(0))
				self->file = block_load_state_file(global::load_assets_dir + mc_blockstates_directory + self->filename, self->id, ArrType());
			else
				self->file = null_;
			
			if (is_string(DsMap(map).Value(/*"default_state"*/ STR(822))))
				self->default_state = string_get_state_vars(DsMap(map).Value(/*"default_state"*/ STR(822)));
			else
				self->default_state = ArrType();
			
			self->default_state_id = block_get_state_id(self->id, self->default_state);
			if (is_real(DsMap(map).Value(/*"subsurface"*/ STR(124))))
				self->subsurface = DsMap(map).Value(/*"subsurface"*/ STR(124));
			else
				self->subsurface = IntType(0);
			
			VarType windmap = DsMap(map).Value(/*"wind"*/ STR(137));
			self->wind_axis = e_vertex_wave_NONE;
			self->wind_zmin = null_;
			if (ds_map_valid(windmap))
			{
				if (is_string(DsMap(windmap).Value(/*"axis"*/ STR(823))))
				{
					if (DsMap(windmap).Value(/*"axis"*/ STR(823)) == /*"y"*/ STR(824))
						self->wind_axis = e_vertex_wave_Z_ONLY;
					else
						self->wind_axis = e_vertex_wave_ALL;
					
				}
				if (is_real(DsMap(windmap).Value(/*"ymin"*/ STR(825))))
					self->wind_zmin = DsMap(windmap).Value(/*"ymin"*/ STR(825));
			}
			if (is_bool(DsMap(map).Value(/*"waterlogged"*/ STR(826))))
				self->waterlogged = DsMap(map).Value(/*"waterlogged"*/ STR(826));
			else
				self->waterlogged = false;
			
			if (is_bool(DsMap(map).Value(/*"require_models"*/ STR(827))))
				self->require_models = DsMap(map).Value(/*"require_models"*/ STR(827));
			else
				self->require_models = false;
			
			VarType timelinemap = DsMap(map).Value(/*"timeline"*/ STR(119));
			self->timeline = false;
			self->model_double = false;
			if (ds_map_valid(timelinemap))
				block_load_timeline(self, timelinemap, DsMap(typemap).Value(timelinemap));
			if (is_bool(DsMap(map).Value(/*"multithreaded"*/ STR(828))))
				self->multithreaded = DsMap(map).Value(/*"multithreaded"*/ STR(828));
			else
				self->multithreaded = true;
			
			VarType idmap = DsMap(map).Value(/*"id"*/ STR(82));
			self->mc_ids = ArrType();
			self->id_state_vars_map = null_;
			if (is_string(idmap))
			{
				self->mc_ids = ArrType::From({ string_replace(idmap, /*"minecraft:"*/ STR(829), /*""*/ STR(0)) });
				DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_id_map)[idmap] = self->id;
			}
			else
				if (ds_map_valid(idmap))
				{
					self->id_state_vars_map = ds_map_create();
					VarType key = ds_map_find_first((IntType)(idmap));
					while (!is_undefined(key))
					{
						array_add(VarType::CreateRef(self->mc_ids), string_replace(key, /*"minecraft:"*/ STR(829), /*""*/ STR(0)));
						DsMap(self->id_state_vars_map)[key] = string_get_state_vars(DsMap(idmap).Value(key));
						DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_id_map)[key] = self->id;
						key = ds_map_find_next((IntType)(idmap), key);
					}
					
				}
			
			self->state_id_model_obj = null_;
			self->state_id_emissive = null_;
			self->state_id_random_offset = null_;
			self->state_id_random_offset_xy = null_;
			self->state_id_subsurface = null_;
			for (IntType sid = IntType(0); sid < self->state_id_amount; sid++)
			{
				VarType curfile, curemissive, curoffset, curoffsetxy;
				curfile = self->file;
				curemissive = self->emissive;
				curoffset = self->random_offset;
				curoffsetxy = self->random_offset_xy;
				if (self->states_map != null_)
				{
					VarType curstate = ds_map_find_first(self->states_map);
					while (!is_undefined(curstate))
					{
						withOne (Object, DsMap(self->states_map).Value(curstate), self->id)
						{
							RealType valid = mod(((IntType)(sid / sReal(value_id))), sReal(value_amount));
							if (sArr(value_filename).Value(valid) != /*""*/ STR(0))
							{
								if (sArr(value_file).Value(valid) == null_)
									sArr(value_file)[valid] = block_load_state_file(global::load_assets_dir + mc_blockstates_directory + sArr(value_filename).Value(valid), self.otherId, ArrType::From({ sVar(name), sVar(value_name).Value(valid) }));
								curfile = sArr(value_file).Value(valid);
							}
							if (sArr(value_emissive).Value(valid) != null_)
								curemissive = sArr(value_emissive).Value(valid);
							if (sArr(value_random_offset).Value(valid) != null_)
								curoffset = sArr(value_random_offset).Value(valid);
							if (sArr(value_random_offset_xy).Value(valid) != null_)
								curoffsetxy = sArr(value_random_offset_xy).Value(valid);
						}
						
						curstate = ds_map_find_next(self->states_map, curstate);
					}
					
				}
				self->state_id_model_obj[sid] = null_;
				withOne (Object, curfile, self->id)
				{
					VarType variant = DsMap(sInt(state_id_map)).Value(sid);
					if (is_undefined(variant))
						variant = DsMap(sInt(state_id_map)).Value(IntType(0));
					ObjType(obj_block, self.otherId)->state_id_model_obj[sid] = variant;
					ObjType(obj_block, self.otherId)->state_id_emissive[sid] = curemissive;
					ObjType(obj_block, self.otherId)->state_id_random_offset[sid] = curoffset;
					ObjType(obj_block, self.otherId)->state_id_random_offset_xy[sid] = curoffsetxy;
				}
				
			}
			return self->id;
		}
		
		return IntType(0);
	}
	
	VarType block_load_model_file(StringType fname, IntType res)
	{
		if (res == null_ && !is_undefined(DsMap(global::load_assets_model_file_map).Value(filename_name(fname))))
			return DsMap(global::load_assets_model_file_map).Value(filename_name(fname));
		if (!file_exists_lib(fname))
		{
			log({ /*"Could not find model file"*/ STR(830), fname });
			return null_;
		}
		IntType typemap, map;
		typemap = ds_int_map_create();
		map = json_load({ fname, typemap });
		if (!ds_map_valid(map))
		{
			log({ /*"Could not parse model file"*/ STR(831), fname });
			ds_map_destroy(typemap);
			return null_;
		}
		withOne (obj_block_load_model_file, (new obj_block_load_model_file)->id, noone)
		{
			self->name = filename_new_ext(filename_name(fname), /*""*/ STR(0));
			self->parent = null_;
			if (res == null_ && is_string(DsMap(map).Value(/*"parent"*/ STR(832))))
				self->parent = block_load_model_file(global::load_assets_dir + mc_models_directory + string_replace(DsMap(map).Value(/*"parent"*/ STR(832)), /*"minecraft:"*/ STR(829), /*""*/ STR(0)) + /*".json"*/ STR(720));
			self->texture_map = null_;
			if (is_real(DsMap(map).Value(/*"textures"*/ STR(833))))
			{
				self->texture_map = ds_map_create();
				if (ds_map_find_value((IntType)(DsMap(typemap).Value(map)), /*"textures"*/ STR(833)) == e_json_type_ARRAY && ds_list_valid(DsMap(map).Value(/*"textures"*/ STR(833))))
				{
					for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(map).Value(/*"textures"*/ STR(833)))); i++)
					{
						StringType texname = ds_list_find_value((IntType)(DsMap(map).Value(/*"textures"*/ STR(833))), i);
						texname = string_replace(texname, /*"minecraft:"*/ STR(829), /*""*/ STR(0));
						DsMap(self->texture_map)[string(i)] = block_load_model_file_texture(self, texname, res);
					}
				}
				else
					if (ds_map_valid(DsMap(map).Value(/*"textures"*/ STR(833))))
					{
						VarType key = ds_map_find_first((IntType)(DsMap(map).Value(/*"textures"*/ STR(833))));
						while (!is_undefined(key))
						{
							StringType texname = ds_map_find_value((IntType)(DsMap(map).Value(/*"textures"*/ STR(833))), key);
							texname = string_replace(texname, /*"minecraft:"*/ STR(829), /*""*/ STR(0));
							DsMap(self->texture_map)[key] = block_load_model_file_texture(self, texname, res);
							key = ds_map_find_next((IntType)(DsMap(map).Value(/*"textures"*/ STR(833))), key);
						}
						
					}
				
			}
			self->element_amount = IntType(0);
			VarType elementslist = DsMap(map).Value(/*"elements"*/ STR(834));
			if (!is_undefined(elementslist))
			{
				BoolType sortsize;
				IntType sizelist;
				if (ds_list_size((IntType)(elementslist)) > IntType(0))
				{
					sortsize = true;
					sizelist = ds_list_create();
				}
				else
				{
					sortsize = false;
					sizelist = null_;
				}
				
				for (IntType i = IntType(0); i < ds_list_size((IntType)(elementslist)); i++)
				{
					withOne (obj_block_load_element, (new obj_block_load_element)->id, self->id)
					{
						VarType elementmap = DsList(elementslist).Value(i);
						self->from = value_get_point3D(DsMap(elementmap).Value(/*"from"*/ STR(835)));
						self->to = value_get_point3D(DsMap(elementmap).Value(/*"to"*/ STR(836)));
						self->size = point3D_sub(self->to, self->from);
						self->volume = self->size.Value(X_) * self->size.Value(Y_) * self->size.Value(Z_);
						VarType rotationmap = DsMap(elementmap).Value(/*"rotation"*/ STR(837));
						if (ds_map_valid(rotationmap))
						{
							VarType origin, angle;
							VecType rot, scale;
							origin = value_get_point3D(DsMap(rotationmap).Value(/*"origin"*/ STR(838)), point3D(IntType(8), IntType(8), IntType(8)));
							angle = IntType(0);
							rot = vec3(IntType(0));
							scale = vec3(IntType(1));
							if (is_real(DsMap(rotationmap).Value(/*"angle"*/ STR(839))))
								angle = snap(clamp(DsMap(rotationmap).Value(/*"angle"*/ STR(839)), -IntType(45), IntType(45)), 22.5);
							if (is_bool(DsMap(rotationmap).Value(/*"rescale"*/ STR(840))) && DsMap(rotationmap).Value(/*"rescale"*/ STR(840)) > 0)
								scale = vec3(1.0 / dcos(abs(angle)));
							if (is_string(DsMap(rotationmap).Value(/*"axis"*/ STR(823))))
							{
								switch (StringType(DsMap(rotationmap).Value(/*"axis"*/ STR(823))).id)
								{
									case 841: // x
									{
										rot.Real(X_) = angle;
										scale.Real(X_) = IntType(1);
										break;
									}
									case 842: // z
									{
										rot.Real(Y_) = angle;
										scale.Real(Y_) = IntType(1);
										break;
									}
									case 824: // y
									{
										rot.Real(Z_) = angle;
										scale.Real(Z_) = IntType(1);
										break;
									}
								}
								
							}
							self->matrix = matrix_create(point3D_mul(origin, -IntType(1)), vec3(IntType(0)), vec3(IntType(1)));
							self->matrix = matrix_multiply(self->matrix, matrix_create(point3D(IntType(0), IntType(0), IntType(0)), vec3(IntType(0)), scale));
							self->matrix = matrix_multiply(self->matrix, matrix_create(origin, rot, vec3(IntType(1))));
							self->rotated = true;
						}
						else
							self->rotated = false;
						
						VarType facesmap = DsMap(elementmap).Value(/*"faces"*/ STR(843));
						for (IntType f = IntType(0); f < e_dir_amount; f++)
						{
							VarType curmap = DsMap(facesmap).Value(dir_get_string(f));
							if (!is_undefined(curmap))
							{
								self->face_render[f] = true;
								self->face_has_uv[f] = false;
								if (ds_list_valid(DsMap(curmap).Value(/*"uv"*/ STR(844))))
								{
									VarType uvlist = DsMap(curmap).Value(/*"uv"*/ STR(844));
									self->face_uv_from[f] = point2D(DsList(uvlist).Value(IntType(0)), DsList(uvlist).Value(IntType(1)));
									self->face_uv_to[f] = point2D(DsList(uvlist).Value(IntType(2)), DsList(uvlist).Value(IntType(3)));
									self->face_has_uv[f] = true;
									VecType uvfrom, uvto;
									uvfrom = self->face_uv_from.Value(f);
									uvto = self->face_uv_to.Value(f);
									self->face_uv_from[f] = vec2(mod_fix(uvfrom.Real(X_), block_size_ + 0.1), mod_fix(uvfrom.Real(Y_), block_size_ + 0.1));
									self->face_uv_to[f] = vec2(mod_fix(uvto.Real(X_), block_size_ + 0.1), mod_fix(uvto.Real(Y_), block_size_ + 0.1));
								}
								self->face_texture[f] = DsMap(curmap).Value(/*"texture"*/ STR(555));
								self->face_rotation[f] = IntType(0);
								if (is_real(DsMap(curmap).Value(/*"rotation"*/ STR(837))))
									self->face_rotation[f] = DsMap(curmap).Value(/*"rotation"*/ STR(837));
							}
							else
								self->face_render[f] = false;
							
						}
						if (sortsize)
						{
							IntType pos;
							for (pos = IntType(0); pos < ds_list_size(sizelist); pos++)
								if (idReal(DsList(sizelist).Value(pos), volume) > self->volume)
									break;
							ds_list_insert(sizelist, pos, self->id);
							ObjType(obj_block_load_model_file, self.otherId)->element_amount++;
						}
						else
						{
							ObjType(obj_block_load_model_file, self.otherId)->element[ObjType(obj_block_load_model_file, self.otherId)->element_amount++] = self->id;
						}
						
					}
					
				}
				if (sortsize)
				{
					self->element = ds_list_create_array(sizelist);
					ds_list_destroy(sizelist);
				}
			}
			if (res == null_)
				DsMap(global::load_assets_model_file_map)[filename_name(fname)] = self->id;
			ds_map_destroy(map);
			return self->id;
		}
		
		return VarType();
	}
	
}
