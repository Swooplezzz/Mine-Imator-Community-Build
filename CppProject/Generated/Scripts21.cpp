/*
	NOTE:
	This file was autogenerated by CppGen, changes may be overwritten and forever lost!
	Modify at your own risk!
	
	[ Generated on 2023.12.17 00:48:08 ]
*/

#include "Scripts.hpp"

namespace CppProject
{
	void bench_update_particles_list(ScopeAny self)
	{
		ArrType files = file_find(particles_directory, /*".miparticles"*/ STR(717));
		sortlist_clear(ObjType(obj_bench_settings, sInt(bench_settings))->particles_list);
		if (array_length(VarType::CreateRef(files)) > IntType(0))
		{
			for (IntType f = IntType(0); f < array_length(VarType::CreateRef(files)); f++)
				sortlist_add(ObjType(obj_bench_settings, sInt(bench_settings))->particles_list, files.Value(f));
			action_bench_particles(self, files.Value(IntType(0)));
		}
		else
			action_bench_particles(self, /*""*/ STR(0));
		
	}
	
	ArrType bezier_curve_cubic(ArrType p1, ArrType p2, ArrType p3, ArrType p4, RealType t)
	{
		ArrType t1, t2, t3, t4, t5;
		t1 = point_lerp(p1, p2, t);
		t2 = point_lerp(p2, p3, t);
		t3 = point_lerp(p3, p4, t);
		t4 = point_lerp(t1, t2, t);
		t5 = point_lerp(t2, t3, t);
		return point_lerp(t4, t5, t);
	}
	
	ArrType bezier_curve_quad(VarType p1, VarType p2, VarType p3, RealType t)
	{
		ArrType t1, t2;
		t1 = point_lerp(p1, p2, t);
		t2 = point_lerp(p2, p3, t);
		return point_lerp(t1, t2, t);
	}
	
	void block_animate(ScopeAny self, IntType root)
	{
		withOne (obj_timeline, (new obj_timeline)->id, self->id)
		{
			self->temp = self->id;
			self->inherit_rot_point = true;
			self->part_of = root;
			self->part_root = root;
			ds_list_add({ ObjType(obj_timeline, root)->part_list, self->id });
			tl_set_parent(ScopeAny(self), { root });
			if (idVar(self.otherId, model_name) != /*""*/ STR(0))
			{
				self->type = e_tl_type_SPECIAL_BLOCK;
				self->model_name = idVar(self.otherId, model_name);
				self->model_state = array_copy_1d(idVar(self.otherId, model_state));
				tl_update_scenery_part(ScopeAny(self));
				self->part_list = ds_list_create();
				if (self->model_file != null_)
				{
					for (IntType p = IntType(0); p < ds_list_size(idInt(self->model_file, file_part_list)); p++)
					{
						IntType partl = tl_new_part(self, DsList(idInt(self->model_file, file_part_list)).Value(p));
						ObjType(obj_timeline, partl)->part_root = root;
						ds_list_add({ self->part_list, partl });
					}
					tl_update_part_list(ScopeAny(self), self->model_file, self->id);
				}
			}
			else
			{
				self->type = e_tl_type_BLOCK;
				self->block_name = idVar(idVar(self.otherId, block), name);
				self->block_state = array_copy_1d(idVar(idVar(self.otherId, block), default_state));
				if (is_string(idVar(self.otherId, variant)))
					state_vars_add(VarType::CreateRef(self->block_state), ArrType::From({ /*"variant"*/ STR(813), idVar(self.otherId, variant) }));
				tl_update_scenery_part(ScopeAny(self));
				self->texture_filtering = true;
			}
			
			self->rot_point_custom = true;
			self->rot_point = array_copy_1d(idVar(self.otherId, rot_point));
			VecType pos = point3D_mul_matrix(idVar(self.otherId, position), matrix_create(point3D(IntType(0), idVec(idVar(ObjType(obj_timeline, root)->temp, scenery), scenery_size).Real(Y_) * block_size_, IntType(0)), vec3(IntType(0), IntType(0), IntType(90)), vec3(IntType(1))));
			self->value_default[e_value_POS_X] = snap(pos.Real(X_), 0.01);
			self->value_default[e_value_POS_Y] = snap(pos.Real(Y_), 0.01);
			self->value_default[e_value_POS_Z] = snap(pos.Real(Z_), 0.01);
			self->value_default[e_value_ROT_X] = idVar(self.otherId, rotation).Value(X_);
			self->value_default[e_value_ROT_Y] = idVar(self.otherId, rotation).Value(Y_);
			self->value_default[e_value_ROT_Z] = idVar(self.otherId, rotation).Value(Z_) + IntType(90);
			if (idVar(self.otherId, texture) != null_)
			{
				self->value_default[e_value_TEXTURE_OBJ] = idVar(self.otherId, texture);
				idInt(self->value_default.Value(e_value_TEXTURE_OBJ), count)++;
			}
			tl_update(ScopeAny(self));
			tl_update_values(ScopeAny(self));
			if (idBool(self.otherId, has_text))
			{
				VarType text, textpos, textrot, textscale, textcolor, textglowcolor, textemissive;
				if (self->part_list == null_)
					self->part_list = ds_list_create();
				text = idVar(self.otherId, text_front);
				textpos = idVar(self.otherId, text_front_position);
				textrot = idVar(self.otherId, text_front_rotation);
				textscale = idVar(self.otherId, text_front_scale);
				textcolor = idVar(self.otherId, text_front_color);
				textglowcolor = idVar(self.otherId, text_front_glow_color);
				textemissive = idVar(self.otherId, text_front_emissive);
				withOne (obj_timeline, (new obj_timeline)->id, self->id)
				{
					self->type = e_tl_type_TEXT;
					self->temp = self->id;
					self->inherit_rot_point = true;
					self->part_of = self.otherId;
					ds_list_add({ ObjType(obj_timeline, self.otherId)->part_list, self->id });
					tl_set_parent(ScopeAny(self), { self.otherId });
					ObjType(obj_timeline, self->id)->text = text;
					tl_update_scenery_part(ScopeAny(self));
					self->value_default[e_value_POS_X] = textpos.Value(X_);
					self->value_default[e_value_POS_Y] = textpos.Value(Y_);
					self->value_default[e_value_POS_Z] = textpos.Value(Z_);
					self->value_default[e_value_ROT_X] = textrot.Value(X_);
					self->value_default[e_value_ROT_Y] = textrot.Value(Y_);
					self->value_default[e_value_ROT_Z] = textrot.Value(Z_);
					self->value_default[e_value_SCA_X] = textscale;
					self->value_default[e_value_SCA_Y] = textscale;
					self->value_default[e_value_SCA_Z] = textscale;
					self->value_default[e_value_RGB_MUL] = textcolor;
					self->value_default[e_value_EMISSIVE] = textemissive;
					if (textemissive > IntType(0))
					{
						self->value_default[e_value_TEXT_OUTLINE] = true;
						self->value_default[e_value_TEXT_OUTLINE_COLOR] = textglowcolor;
					}
					tl_update(ScopeAny(self));
					tl_update_values(ScopeAny(self));
				}
				
				text = idVar(self.otherId, text_back);
				textpos = idVar(self.otherId, text_back_position);
				textrot = idVar(self.otherId, text_back_rotation);
				textscale = idVar(self.otherId, text_back_scale);
				textcolor = idVar(self.otherId, text_back_color);
				textglowcolor = idVar(self.otherId, text_back_glow_color);
				textemissive = idVar(self.otherId, text_back_emissive);
				withOne (obj_timeline, (new obj_timeline)->id, self->id)
				{
					self->type = e_tl_type_TEXT;
					self->temp = self->id;
					self->inherit_rot_point = true;
					self->part_of = self.otherId;
					ds_list_add({ ObjType(obj_timeline, self.otherId)->part_list, self->id });
					tl_set_parent(ScopeAny(self), { self.otherId });
					ObjType(obj_timeline, self->id)->text = text;
					tl_update_scenery_part(ScopeAny(self));
					self->value_default[e_value_POS_X] = textpos.Value(X_);
					self->value_default[e_value_POS_Y] = textpos.Value(Y_);
					self->value_default[e_value_POS_Z] = textpos.Value(Z_);
					self->value_default[e_value_ROT_X] = textrot.Value(X_);
					self->value_default[e_value_ROT_Y] = textrot.Value(Y_);
					self->value_default[e_value_ROT_Z] = textrot.Value(Z_);
					self->value_default[e_value_SCA_X] = textscale;
					self->value_default[e_value_SCA_Y] = textscale;
					self->value_default[e_value_SCA_Z] = textscale;
					self->value_default[e_value_RGB_MUL] = textcolor;
					self->value_default[e_value_EMISSIVE] = textemissive;
					if (textemissive > IntType(0))
					{
						self->value_default[e_value_TEXT_OUTLINE] = true;
						self->value_default[e_value_TEXT_OUTLINE_COLOR] = textglowcolor;
					}
					tl_update(ScopeAny(self));
					tl_update_values(ScopeAny(self));
				}
				
			}
			if (idVar(self.otherId, pattern_type) != /*""*/ STR(0))
			{
				self->pattern_base_color = idVar(self.otherId, banner_color);
				self->pattern_pattern_list = array_copy_1d(idVar(self.otherId, banner_patterns));
				self->pattern_color_list = array_copy_1d(idVar(self.otherId, banner_pattern_colors));
				self->pattern_type = idVar(self.otherId, pattern_type);
				if (self->pattern_type == /*"banner"*/ STR(814))
				{
					VarType stand = DsList(self->tree_list).Value(IntType(0));
					idInt(stand, pattern_skin) = self->pattern_skin;
					idVar(stand, pattern_type) = /*"banner"*/ STR(814);
					VarType banner = DsList(idInt(stand, tree_list)).Value(IntType(0));
					idInt(banner, pattern_skin) = self->pattern_skin;
					idVar(banner, pattern_type) = /*"banner"*/ STR(814);
				}
				array_add(VarType::CreateRef(global::pattern_update), self->id);
			}
		}
		
	}
	
	RealType block_generate_liquid(ScopeAny self, RealType waterlogged)
	{
		BoolType matchxp, matchxn, matchyp, matchyn, matchzp, matchzn;
		BoolType solidxp, solidxn, solidyp, solidyn, solidzp, solidzn;
		matchxp = (!sBool(build_edge_xp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z)) == sInt(block_current));
		matchxn = (!sBool(build_edge_xn) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z)) == sInt(block_current));
		matchyp = (!sBool(build_edge_yp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)) == sInt(block_current));
		matchyn = (!sBool(build_edge_yn) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)) == sInt(block_current));
		matchzp = (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z) + IntType(1)) == sInt(block_current));
		matchzn = (!sBool(build_edge_zn) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z) - IntType(1)) == sInt(block_current));
		solidxp = (sInt(block_face_min_depth_xp) == e_block_depth_DEPTH0 && sBool(block_face_full_xp));
		solidxn = (sInt(block_face_min_depth_xn) == e_block_depth_DEPTH0 && sBool(block_face_full_xn));
		solidyp = (sInt(block_face_min_depth_yp) == e_block_depth_DEPTH0 && sBool(block_face_full_yp));
		solidyn = (sInt(block_face_min_depth_yn) == e_block_depth_DEPTH0 && sBool(block_face_full_yn));
		solidzp = (sInt(block_face_min_depth_zp) == e_block_depth_DEPTH0 && sBool(block_face_full_zp));
		solidzn = (sInt(block_face_min_depth_zn) == e_block_depth_DEPTH0 && sBool(block_face_full_zn));
		matchxp = (matchxp || (!sBool(build_edge_xp) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z))));
		matchxn = (matchxn || (!sBool(build_edge_xn) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z))));
		matchyp = (matchyp || (!sBool(build_edge_yp) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z))));
		matchyn = (matchyn || (!sBool(build_edge_yn) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z))));
		matchzp = (matchzp || (!sBool(build_edge_zp) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z) + IntType(1))));
		matchzn = (matchzn || (!sBool(build_edge_zn) && builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y), sInt(build_pos_z) - IntType(1))));
		if (global::_app->project_render_liquid_animation > 0)
		{
			IntType model;
			if (matchzp)
			{
				if (solidxp && !sBool(build_edge_xp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1)) != sInt(block_current))
				{
					solidxp = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1));
					if (model != null_)
						solidxp = (idInt(model, face_min_depth_xn) == e_block_depth_DEPTH0 && idBool(model, face_full_xn));
				}
				if (solidxn && !sBool(build_edge_xn) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1)) != sInt(block_current))
				{
					solidxn = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1));
					if (model != null_)
						solidxn = (idInt(model, face_min_depth_xp) == e_block_depth_DEPTH0 && idBool(model, face_full_xp));
				}
				if (solidyp && !sBool(build_edge_yp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) + IntType(1)) != sInt(block_current))
				{
					solidyp = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) + IntType(1));
					if (model != null_)
						solidyp = (idInt(model, face_min_depth_yn) == e_block_depth_DEPTH0 && idBool(model, face_full_yn));
				}
				if (solidyn && !sBool(build_edge_yn) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) + IntType(1)) != sInt(block_current))
				{
					solidyn = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) + IntType(1));
					if (model != null_)
						solidyn = (idInt(model, face_min_depth_yp) == e_block_depth_DEPTH0 && idBool(model, face_full_yp));
				}
			}
			if (matchzn)
			{
				if (solidxp && !sBool(build_edge_xp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z) - IntType(1)) != sInt(block_current))
				{
					solidxp = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z) - IntType(1));
					if (model != null_)
						solidxp = (idInt(model, face_min_depth_xn) == e_block_depth_DEPTH0 && idBool(model, face_full_xn));
				}
				if (solidxn && !sBool(build_edge_xn) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z) - IntType(1)) != sInt(block_current))
				{
					solidxn = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z) - IntType(1));
					if (model != null_)
						solidxn = (idInt(model, face_min_depth_xp) == e_block_depth_DEPTH0 && idBool(model, face_full_xp));
				}
				if (solidyp && !sBool(build_edge_yp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) - IntType(1)) != sInt(block_current))
				{
					solidyp = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) - IntType(1));
					if (model != null_)
						solidyp = (idInt(model, face_min_depth_yn) == e_block_depth_DEPTH0 && idBool(model, face_full_yn));
				}
				if (solidyn && !sBool(build_edge_yn) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) - IntType(1)) != sInt(block_current))
				{
					solidyn = false;
					model = builder_get_render_model(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) - IntType(1));
					if (model != null_)
						solidyn = (idInt(model, face_min_depth_yp) == e_block_depth_DEPTH0 && idBool(model, face_full_yp));
				}
			}
		}
		if ((matchxp || solidxp) && (matchxn || solidxn) && (matchyp || solidyp) && (matchyn || solidyn) && matchzp && (matchzn || solidzn))
			return IntType(0);
		IntType slot, dep, vbuf;
		RealType sheetwidth, sheetheight;
		RealType slotstillposx, slotstillposy, slotstillsizex, slotstillsizey;
		RealType slotflowposx, slotflowposy, slotflowsizex, slotflowsizey;
		slot = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_liquid_slot_map).Value(idVar(sInt(block_current), name));
		dep = DsList(ObjType(obj_resource, global::mc_res)->block_sheet_ani_depth_list).Value(slot);
		if (idVar(sInt(block_current), name) == /*"water"*/ STR(815))
			vbuf = e_block_vbuffer_WATER;
		else
			vbuf = e_block_vbuffer_ANIMATED;
		
		sheetwidth = block_sheet_ani_width;
		sheetheight = block_sheet_ani_height;
		slotstillposx = (mod(slot, sheetwidth)) * block_size_;
		slotstillposy = ((IntType)(slot / sheetwidth)) * block_size_;
		slotstillsizex = 1.0 / (sheetwidth * block_size_);
		slotstillsizey = 1.0 / (sheetheight * block_size_);
		slot = DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_liquid_slot_map).Value(/*"flowing_"*/ STR(816) + idVar(sInt(block_current), name));
		slotflowposx = (mod(slot, sheetwidth)) * block_size_;
		slotflowposy = ((IntType)(slot / sheetwidth)) * block_size_;
		slotflowsizex = 1.0 / (sheetwidth * block_size_);
		slotflowsizey = 1.0 / (sheetheight * block_size_);
		BoolType topflow;
		RealType topangle;
		topflow = true;
		topangle = IntType(0);
		RealType level = ((waterlogged > 0) ? IntType(0) : sReal(block_state_id_current));
		RealType corner0z, corner1z, corner2z, corner3z, minz, averagez;
		if (global::_app->project_render_liquid_animation > 0)
		{
			sInt(block_vertex_wave) = e_vertex_wave_Z_ONLY;
			if (matchzn)
				sInt(block_vertex_wave_zmin) = null_;
			else
				sInt(block_vertex_wave_zmin) = sInt(block_pos_z);
			
		}
		sVar(block_vertex_rgb) = c_white;
		sReal(block_vertex_alpha) = IntType(1);
		if ((IntType)(level / IntType(8)) || matchzp)
		{
			corner0z = block_size_;
			corner1z = block_size_;
			corner2z = block_size_;
			corner3z = block_size_;
			minz = block_size_;
			averagez = block_size_;
			topflow = false;
		}
		else
		{
			RealType sidelevelxp, sidelevelxn, sidelevelyp, sidelevelyn;
			sidelevelxp = level;
			sidelevelxn = level;
			sidelevelyp = level;
			sidelevelyn = level;
			RealType corner0level, corner1level, corner2level, corner3level;
			corner0level = level;
			corner1level = level;
			corner2level = level;
			corner3level = level;
			if (!(waterlogged > 0))
			{
				if (!sBool(build_edge_xp) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						sidelevelxp = IntType(8);
					else
						if (matchxp)
							sidelevelxp = builder_get_state_id(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_xn) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						sidelevelxn = IntType(8);
					else
						if (matchxn)
							sidelevelxn = builder_get_state_id(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_yp) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						sidelevelyp = IntType(8);
					else
						if (matchyp)
							sidelevelyp = builder_get_state_id(self, sInt(build_pos_x), sInt(build_pos_y) + IntType(1), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_yn) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						sidelevelyn = IntType(8);
					else
						if (matchyn)
							sidelevelyn = builder_get_state_id(self, sInt(build_pos_x), sInt(build_pos_y) - IntType(1), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_xn) && !sBool(build_edge_yn) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						corner0level = IntType(8);
					else
						if (builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)) == sInt(block_current))
							corner0level = builder_get_state_id(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_xp) && !sBool(build_edge_yn) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						corner1level = IntType(8);
					else
						if (builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z)) == sInt(block_current))
							corner1level = builder_get_state_id(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) - IntType(1), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_xp) && !sBool(build_edge_yp) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) + IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						corner2level = IntType(8);
					else
						if (builder_get_block(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)) == sInt(block_current))
							corner2level = builder_get_state_id(self, sInt(build_pos_x) + IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z));
					
				}
				if (!sBool(build_edge_xn) && !sBool(build_edge_yp) && !builder_get_waterlogged(Scope<obj_builder_thread>(self), sInt(build_pos_x) - IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)))
				{
					if (!sBool(build_edge_zp) && builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z) + IntType(1)) == sInt(block_current))
						corner3level = IntType(8);
					else
						if (builder_get_block(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z)) == sInt(block_current))
							corner3level = builder_get_state_id(self, sInt(build_pos_x) - IntType(1), sInt(build_pos_y) + IntType(1), sInt(build_pos_z));
					
				}
			}
			IntType flowxp, flowxn, flowyp, flowyn;
			flowxp = IntType(0);
			flowxn = IntType(0);
			flowyp = IntType(0);
			flowyn = IntType(0);
			if (mod(sidelevelxp, IntType(8)) < level)
				flowxn++;
			else
				if (mod(sidelevelxp, IntType(8)) > level)
					flowxp++;
			
			if (mod(sidelevelxn, IntType(8)) < level)
				flowxp++;
			else
				if (mod(sidelevelxn, IntType(8)) > level)
					flowxn++;
			
			if (mod(sidelevelyp, IntType(8)) < level)
				flowyn++;
			else
				if (mod(sidelevelyp, IntType(8)) > level)
					flowyp++;
			
			if (mod(sidelevelyn, IntType(8)) < level)
				flowyp++;
			else
				if (mod(sidelevelyn, IntType(8)) > level)
					flowyn++;
			
			RealType myz, sidezxp, sidezxn, sidezyp, sidezyn;
			myz = IntType(14) - (level / 7.0) * 13.5;
			sidezxp = (((IntType)(sidelevelxp / IntType(8))) ? block_size_ : (IntType(14) - ((sidelevelxp / 7.0) * 13.5)));
			sidezxn = (((IntType)(sidelevelxn / IntType(8))) ? block_size_ : (IntType(14) - ((sidelevelxn / 7.0) * 13.5)));
			sidezyp = (((IntType)(sidelevelyp / IntType(8))) ? block_size_ : (IntType(14) - ((sidelevelyp / 7.0) * 13.5)));
			sidezyn = (((IntType)(sidelevelyn / IntType(8))) ? block_size_ : (IntType(14) - ((sidelevelyn / 7.0) * 13.5)));
			corner0z = (((IntType)(corner0level / IntType(8))) ? block_size_ : (IntType(14) - ((corner0level / 7.0) * 13.5)));
			corner1z = (((IntType)(corner1level / IntType(8))) ? block_size_ : (IntType(14) - ((corner1level / 7.0) * 13.5)));
			corner2z = (((IntType)(corner2level / IntType(8))) ? block_size_ : (IntType(14) - ((corner2level / 7.0) * 13.5)));
			corner3z = (((IntType)(corner3level / IntType(8))) ? block_size_ : (IntType(14) - ((corner3level / 7.0) * 13.5)));
			corner0z = max({ corner0z, sidezxn, sidezyn, myz });
			corner1z = max({ corner1z, sidezxp, sidezyn, myz });
			corner2z = max({ corner2z, sidezxp, sidezyp, myz });
			corner3z = max({ corner3z, sidezxn, sidezyp, myz });
			averagez = (corner0z + corner1z + corner2z + corner3z) / 4.0;
			minz = min({ corner0z, corner1z, corner2z, corner3z });
			if ((!(flowxn > 0) && !(flowxp > 0) && !(flowyn > 0) && !(flowyp > 0)) || (flowxn > 0 && flowxp > 0 && flowyn > 0 && flowyp > 0) || (flowxn > 0 && flowxp > 0 && !(flowyn > 0) && !(flowyp > 0)) || (!(flowxn > 0) && !(flowxp > 0) && flowyn > 0 && flowyp > 0))
				topflow = false;
			else
				if (flowxn > 0 && flowxp > 0 && flowyp > 0)
					topangle = IntType(0);
				else
					if (flowxn > 0 && flowxp > 0 && flowyn > 0)
						topangle = IntType(180);
					else
						if (flowxp > 0 && flowyn > 0 && flowyp > 0)
							topangle = IntType(90);
						else
							if (flowxn > 0 && flowyn > 0 && flowyp > 0)
								topangle = IntType(270);
							else
								if (flowxn > 0 && flowyn > 0)
									topangle = IntType(180) + IntType(45) + IntType(10) * (flowxn - IntType(1)) - IntType(10) * (flowyn - IntType(1));
								else
									if (flowxp > 0 && flowyn > 0)
										topangle = IntType(180) - IntType(45) + IntType(10) * (flowyn - IntType(1)) - IntType(10) * (flowxp - IntType(1));
									else
										if (flowxn > 0 && flowyp > 0)
											topangle = IntType(270) + IntType(45) + IntType(10) * (flowyp - IntType(1)) - IntType(10) * (flowxn - IntType(1));
										else
											if (flowxp > 0 && flowyp > 0)
												topangle = IntType(45) + IntType(10) * (flowxp - IntType(1)) - IntType(10) * (flowyp - IntType(1));
											else
												if (flowyp > 0)
													topangle = IntType(0);
												else
													if (flowxp > 0)
														topangle = IntType(90);
													else
														if (flowyn > 0)
															topangle = IntType(180);
														else
															if (flowxn > 0)
																topangle = IntType(270);
													
												
											
										
									
								
							
						
					
				
			
			
		}
		
		RealType sidetex0x, sidetex0y, sidetex1x, sidetex1y, sidetex2x, sidetex2y, sidetex3x, sidetex3y;
		RealType cornerlefttex0x, cornerlefttex0y, cornerlefttex1x, cornerlefttex1y, cornerlefttex2x, cornerlefttex2y, cornerlefttex3x, cornerlefttex3y;
		RealType cornerrighttex0x, cornerrighttex0y, cornerrighttex1x, cornerrighttex1y, cornerrighttex2x, cornerrighttex2y, cornerrighttex3x, cornerrighttex3y;
		RealType toptex0x, toptex0y, toptex1x, toptex1y, toptex2x, toptex2y, toptex3x, toptex3y;
		RealType topmidtexx, topmidtexy;
		sidetex0x = IntType(0);
		sidetex0y = block_size_ - minz;
		sidetex1x = block_size_;
		sidetex1y = block_size_ - minz;
		sidetex2x = block_size_;
		sidetex2y = block_size_;
		sidetex3x = IntType(0);
		sidetex3y = block_size_;
		cornerlefttex0x = IntType(0);
		cornerlefttex0y = block_size_ - corner0z;
		cornerlefttex1x = IntType(0);
		cornerlefttex1y = block_size_ - corner1z;
		cornerlefttex2x = IntType(0);
		cornerlefttex2y = block_size_ - corner2z;
		cornerlefttex3x = IntType(0);
		cornerlefttex3y = block_size_ - corner3z;
		cornerrighttex0x = block_size_;
		cornerrighttex0y = block_size_ - corner0z;
		cornerrighttex1x = block_size_;
		cornerrighttex1y = block_size_ - corner1z;
		cornerrighttex2x = block_size_;
		cornerrighttex2y = block_size_ - corner2z;
		cornerrighttex3x = block_size_;
		cornerrighttex3y = block_size_ - corner3z;
		if (topangle != IntType(0))
		{
			RealType p = (mod_fix(topangle, IntType(90)) / 90.0) * block_size_;
			toptex0x = p;
			toptex0y = IntType(0);
			toptex1x = block_size_;
			toptex1y = p;
			toptex2x = block_size_ - p;
			toptex2y = block_size_;
			toptex3x = IntType(0);
			toptex3y = block_size_ - p;
			for (IntType _it = 0, _it_max = (IntType)(topangle / IntType(90)); _it < _it_max; _it++)
			{
				RealType tmpx, tmpy;
				tmpx = toptex0x;
				tmpy = toptex0y;
				toptex0x = toptex1x;
				toptex0y = toptex1y;
				toptex1x = toptex2x;
				toptex1y = toptex2y;
				toptex2x = toptex3x;
				toptex2y = toptex3y;
				toptex3x = tmpx;
				toptex3y = tmpy;
			}
		}
		else
		{
			toptex0x = IntType(0);
			toptex0y = IntType(0);
			toptex1x = block_size_;
			toptex1y = IntType(0);
			toptex2x = block_size_;
			toptex2y = block_size_;
			toptex3x = IntType(0);
			toptex3y = block_size_;
		}
		
		topmidtexx = block_size_ / 2.0;
		topmidtexy = block_size_ / 2.0;
		sidetex0x = (sidetex0x + slotflowposx) * slotflowsizex;
		sidetex0y = (sidetex0y + slotflowposy) * slotflowsizey;
		sidetex1x = (sidetex1x + slotflowposx) * slotflowsizex;
		sidetex1y = (sidetex1y + slotflowposy) * slotflowsizey;
		sidetex2x = (sidetex2x + slotflowposx) * slotflowsizex;
		sidetex2y = (sidetex2y + slotflowposy) * slotflowsizey;
		sidetex3x = (sidetex3x + slotflowposx) * slotflowsizex;
		sidetex3y = (sidetex3y + slotflowposy) * slotflowsizey;
		cornerlefttex0x = (cornerlefttex0x + slotflowposx) * slotflowsizex;
		cornerlefttex0y = (cornerlefttex0y + slotflowposy) * slotflowsizey;
		cornerlefttex1x = (cornerlefttex1x + slotflowposx) * slotflowsizex;
		cornerlefttex1y = (cornerlefttex1y + slotflowposy) * slotflowsizey;
		cornerlefttex2x = (cornerlefttex2x + slotflowposx) * slotflowsizex;
		cornerlefttex2y = (cornerlefttex2y + slotflowposy) * slotflowsizey;
		cornerlefttex3x = (cornerlefttex3x + slotflowposx) * slotflowsizex;
		cornerlefttex3y = (cornerlefttex3y + slotflowposy) * slotflowsizey;
		cornerrighttex0x = (cornerrighttex0x + slotflowposx) * slotflowsizex;
		cornerrighttex0y = (cornerrighttex0y + slotflowposy) * slotflowsizey;
		cornerrighttex1x = (cornerrighttex1x + slotflowposx) * slotflowsizex;
		cornerrighttex1y = (cornerrighttex1y + slotflowposy) * slotflowsizey;
		cornerrighttex2x = (cornerrighttex2x + slotflowposx) * slotflowsizex;
		cornerrighttex2y = (cornerrighttex2y + slotflowposy) * slotflowsizey;
		cornerrighttex3x = (cornerrighttex3x + slotflowposx) * slotflowsizex;
		cornerrighttex3y = (cornerrighttex3y + slotflowposy) * slotflowsizey;
		if (topflow)
		{
			toptex0x = (toptex0x + slotflowposx) * slotflowsizex;
			toptex0y = (toptex0y + slotflowposy) * slotflowsizey;
			toptex1x = (toptex1x + slotflowposx) * slotflowsizex;
			toptex1y = (toptex1y + slotflowposy) * slotflowsizey;
			toptex2x = (toptex2x + slotflowposx) * slotflowsizex;
			toptex2y = (toptex2y + slotflowposy) * slotflowsizey;
			toptex3x = (toptex3x + slotflowposx) * slotflowsizex;
			toptex3y = (toptex3y + slotflowposy) * slotflowsizey;
			topmidtexx = (topmidtexx + slotflowposx) * slotflowsizex;
			topmidtexy = (topmidtexy + slotflowposy) * slotflowsizey;
		}
		else
		{
			toptex0x = (toptex0x + slotstillposx) * slotstillsizex;
			toptex0y = (toptex0y + slotstillposy) * slotstillsizey;
			toptex1x = (toptex1x + slotstillposx) * slotstillsizex;
			toptex1y = (toptex1y + slotstillposy) * slotstillsizey;
			toptex2x = (toptex2x + slotstillposx) * slotstillsizex;
			toptex2y = (toptex2y + slotstillposy) * slotstillsizey;
			toptex3x = (toptex3x + slotstillposx) * slotstillsizex;
			toptex3y = (toptex3y + slotstillposy) * slotstillsizey;
			topmidtexx = (topmidtexx + slotstillposx) * slotstillsizex;
			topmidtexy = (topmidtexy + slotstillposy) * slotstillsizey;
		}
		
		RealType x1, x2, y1, y2, z1, z2;
		RealType midx, midy, midz;
		x1 = sInt(block_pos_x);
		y1 = sInt(block_pos_y);
		z1 = floor(sInt(block_pos_z));
		x2 = x1 + block_size_;
		y2 = y1 + block_size_;
		z2 = z1 + minz;
		midx = x1 + block_size_ / 2.0;
		midy = y1 + block_size_ / 2.0;
		midz = z1 + averagez;
		if (waterlogged > 0)
		{
			RealType indent = 0.05;
			if (!matchxp)
				x2 -= indent;
			if (!matchxn)
				x1 += indent;
			if (!matchyp)
				y2 -= indent;
			if (!matchyn)
				y1 += indent;
		}
		corner0z += z1;
		corner1z += z1;
		corner2z += z1;
		corner3z += z1;
		sVar(block_vbuffer_current) = ObjType(obj_builder, global::mc_builder)->vbuffer[dep][vbuf];
		sVar(block_vertex_emissive) = idVar(sInt(block_current), emissive);
		if (!matchxp && !solidxp)
		{
			builder_add_face(Scope<obj_builder_thread>(self), x2, y2, z2, x2, y1, z2, x2, y1, z1, x2, y2, z1, sidetex0x, sidetex0y, sidetex1x, sidetex1y, sidetex2x, sidetex2y, sidetex3x, sidetex3y, null_);
			if (corner1z > corner2z)
				builder_add_triangle(Scope<obj_builder_thread>(self), x2, y1, z2, x2, y2, z2, x2, y1, corner1z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerrighttex1x, cornerrighttex1y, null_);
			else
				builder_add_triangle(Scope<obj_builder_thread>(self), x2, y1, z2, x2, y2, z2, x2, y2, corner2z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerlefttex2x, cornerlefttex2y, null_);
			
		}
		if (!matchxn && !solidxn)
		{
			builder_add_face(Scope<obj_builder_thread>(self), x1, y1, z2, x1, y2, z2, x1, y2, z1, x1, y1, z1, sidetex0x, sidetex0y, sidetex1x, sidetex1y, sidetex2x, sidetex2y, sidetex3x, sidetex3y, null_);
			if (corner3z > corner0z)
				builder_add_triangle(Scope<obj_builder_thread>(self), x1, y2, z2, x1, y1, z2, x1, y2, corner3z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerrighttex3x, cornerrighttex3y, null_);
			else
				builder_add_triangle(Scope<obj_builder_thread>(self), x1, y2, z2, x1, y1, z2, x1, y1, corner0z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerlefttex0x, cornerlefttex0y, null_);
			
		}
		if (!matchyp && !solidyp)
		{
			builder_add_face(Scope<obj_builder_thread>(self), x1, y2, z2, x2, y2, z2, x2, y2, z1, x1, y2, z1, sidetex0x, sidetex0y, sidetex1x, sidetex1y, sidetex2x, sidetex2y, sidetex3x, sidetex3y, null_);
			if (corner2z > corner3z)
				builder_add_triangle(Scope<obj_builder_thread>(self), x2, y2, z2, x1, y2, z2, x2, y2, corner2z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerrighttex2x, cornerrighttex2y, null_);
			else
				builder_add_triangle(Scope<obj_builder_thread>(self), x2, y2, z2, x1, y2, z2, x1, y2, corner3z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerlefttex3x, cornerlefttex3y, null_);
			
		}
		if (!matchyn && !solidyn)
		{
			builder_add_face(Scope<obj_builder_thread>(self), x2, y1, z2, x1, y1, z2, x1, y1, z1, x2, y1, z1, sidetex0x, sidetex0y, sidetex1x, sidetex1y, sidetex2x, sidetex2y, sidetex3x, sidetex3y, null_);
			if (corner0z > corner1z)
				builder_add_triangle(Scope<obj_builder_thread>(self), x1, y1, z2, x2, y1, z2, x1, y1, corner0z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerrighttex0x, cornerrighttex0y, null_);
			else
				builder_add_triangle(Scope<obj_builder_thread>(self), x1, y1, z2, x2, y1, z2, x2, y1, corner1z, sidetex1x, sidetex1y, sidetex0x, sidetex0y, cornerlefttex1x, cornerlefttex1y, null_);
			
		}
		if (!matchzp)
		{
			builder_add_triangle(Scope<obj_builder_thread>(self), midx, midy, midz, x1, y1, corner0z, x2, y1, corner1z, topmidtexx, topmidtexy, toptex0x, toptex0y, toptex1x, toptex1y, null_);
			builder_add_triangle(Scope<obj_builder_thread>(self), midx, midy, midz, x2, y1, corner1z, x2, y2, corner2z, topmidtexx, topmidtexy, toptex1x, toptex1y, toptex2x, toptex2y, null_);
			builder_add_triangle(Scope<obj_builder_thread>(self), midx, midy, midz, x2, y2, corner2z, x1, y2, corner3z, topmidtexx, topmidtexy, toptex2x, toptex2y, toptex3x, toptex3y, null_);
			builder_add_triangle(Scope<obj_builder_thread>(self), midx, midy, midz, x1, y2, corner3z, x1, y1, corner0z, topmidtexx, topmidtexy, toptex3x, toptex3y, toptex0x, toptex0y, null_);
		}
		if (!matchzn && !solidzn)
			builder_add_face(Scope<obj_builder_thread>(self), x1, y2, z1, x2, y2, z1, x2, y1, z1, x1, y1, z1, toptex3x, toptex3y, toptex2x, toptex2y, toptex1x, toptex1y, toptex0x, toptex0y, null_);
		sVar(block_vertex_rgb) = c_white;
		sReal(block_vertex_alpha) = IntType(1);
		return 0.0;
	}
	
	RealType block_get_state_id(VarType block, VarType vars)
	{
		IntType varslen = array_length(VarType::CreateRef(vars));
		if (varslen == IntType(0) || ObjType(obj_block, block)->states_map == null_)
			return IntType(0);
		RealType sid = IntType(0);
		for (IntType i = IntType(0); i < varslen; i += IntType(2))
		{
			VarType statename, valname, state, valid;
			statename = vars.Value(i);
			valname = vars.Value(i + IntType(1));
			if (statename == /*"id"*/ STR(86))
				continue;
			state = DsMap(ObjType(obj_block, block)->states_map).Value(statename);
			if (is_undefined(state))
				continue;
			valid = DsMap(idInt(state, value_map)).Value(valname);
			if (is_undefined(valid))
				continue;
			sid += idReal(state, value_id) * valid;
		}
		return sid;
	}
	
	ArrType block_get_state_id_state_vars(VarType block, VarType stateid)
	{
		ArrType vars = ArrType();
		if (idInt(block, states_map) != null_)
		{
			VarType key;
			IntType i;
			key = ds_map_find_first(idInt(block, states_map));
			i = IntType(0);
			while (!is_undefined(key))
			{
				vars[i * IntType(2)] = idVar(DsMap(idInt(block, states_map)).Value(key), name);
				vars[i * IntType(2) + IntType(1)] = block_get_state_id_value(block, stateid, idVar(DsMap(idInt(block, states_map)).Value(key), name));
				key = ds_map_find_next(idInt(block, states_map), key);
				i++;
			}
			
		}
		return vars;
	}
	
	VarType block_get_state_id_value(VarType block, VarType stateid, VarType name)
	{
		VarType state;
		if (block == null_ || idInt(block, states_map) == null_)
			return VarType();
		state = DsMap(idInt(block, states_map)).Value(name);
		if (is_undefined(state))
			return VarType();
		return idVar(state, value_name).Value(mod(((IntType)(stateid / idReal(state, value_id))), idReal(state, value_amount)));
	}
	
	IntType block_get_timeline(Scope<obj_builder_thread> self, VarType block, VarType stateid)
	{
		IntType pos = self->build_pos;
		withOne (obj_block_tl, (new obj_block_tl)->id, self->id)
		{
			ObjType(obj_block_tl, self->id)->block = block;
			self->model_name = idVar(block, tl_model_name);
			self->model_state = ArrType();
			if (self->model_name != /*""*/ STR(0))
			{
				if (!idBool(block, tl_has_model_state))
					self->model_state = block_get_state_id_state_vars(block, stateid);
				else
					if (idInt(block, tl_model_state_amount) == IntType(0))
						self->model_state = array_copy_1d(idVar(block, tl_model_state));
				
				for (IntType i = IntType(0); i < idInt(block, tl_model_state_amount); i++)
				{
					VarType curstate = idVar(block, tl_model_state).Value(i);
					if (array_contains(ObjType(obj_block_tl_state, curstate)->state_id, stateid))
					{
						self->model_state = array_copy_1d(ObjType(obj_block_tl_state, curstate)->value);
						break;
					}
				}
				if (DsMap(ObjType(obj_builder, global::mc_builder)->block_decorated_pot_sherds_map).Value(pos) != VarType())
					self->model_state = array_copy_1d(DsMap(ObjType(obj_builder, global::mc_builder)->block_decorated_pot_sherds_map).Value(pos));
			}
			self->has_text = idBool(block, tl_has_text);
			if (self->has_text)
			{
				self->text_front = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_front_map).Value(pos);
				self->text_front_color = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_front_color_map).Value(pos);
				self->text_front_glow_color = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_front_glow_color_map).Value(pos);
				self->text_front_emissive = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_front_glowing_map).Value(pos);
				self->text_back = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_back_map).Value(pos);
				self->text_back_color = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_back_color_map).Value(pos);
				self->text_back_glow_color = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_back_glow_color_map).Value(pos);
				self->text_back_emissive = DsMap(ObjType(obj_builder, global::mc_builder)->block_text_back_glowing_map).Value(pos);
				if (is_undefined(self->text_front))
				{
					self->text_front = /*""*/ STR(0);
					self->text_front_color = c_black;
					self->text_front_glow_color = c_black;
					self->text_front_emissive = IntType(0);
				}
				if (is_undefined(self->text_back))
				{
					self->text_back = /*""*/ STR(0);
					self->text_back_color = c_black;
					self->text_back_glow_color = c_black;
					self->text_back_emissive = IntType(0);
				}
				self->text_front_position = idVar(block, tl_text_front_position);
				self->text_front_rotation = idVar(block, tl_text_front_rotation);
				self->text_front_scale = idVar(block, tl_text_front_scale);
				self->text_back_position = idVar(block, tl_text_back_position);
				self->text_back_rotation = idVar(block, tl_text_back_rotation);
				self->text_back_scale = idVar(block, tl_text_back_scale);
			}
			self->pattern_type = idVar(block, tl_pattern_type);
			if (self->pattern_type != /*""*/ STR(0))
			{
				self->banner_color = DsMap(ObjType(obj_builder, global::mc_builder)->block_banner_color_map).Value(pos);
				self->banner_patterns = DsMap(ObjType(obj_builder, global::mc_builder)->block_banner_patterns_map).Value(pos);
				self->banner_pattern_colors = DsMap(ObjType(obj_builder, global::mc_builder)->block_banner_pattern_colors_map).Value(pos);
				if (is_undefined(self->banner_color))
				{
					self->banner_color = c_white;
					self->banner_patterns = ArrType();
					self->banner_pattern_colors = ArrType();
				}
			}
			if (DsMap(ObjType(obj_builder, global::mc_builder)->block_skull_map).Value(pos) != VarType())
			{
				VarType userid = DsMap(ObjType(obj_builder, global::mc_builder)->block_skull_map).Value(pos);
				self->texture = DsMap(ObjType(obj_builder, global::mc_builder)->block_skull_res_map).Value(userid);
			}
			else
				self->texture = null_;
			
			self->rot_point = idVar(block, tl_rot_point);
			self->position = idVar(block, tl_position);
			self->rotation = idVar(block, tl_rotation);
			for (IntType i = IntType(0); i < idInt(block, tl_rot_point_state_amount); i++)
			{
				VarType curstate = idArr(block, tl_rot_point_state).Value(i);
				if (array_contains(ObjType(obj_block_tl_state, curstate)->state_id, stateid))
				{
					self->rot_point = ObjType(obj_block_tl_state, curstate)->value;
					break;
				}
			}
			for (IntType i = IntType(0); i < idInt(block, tl_position_state_amount); i++)
			{
				VarType curstate = idArr(block, tl_position_state).Value(i);
				if (array_contains(ObjType(obj_block_tl_state, curstate)->state_id, stateid))
				{
					self->position = ObjType(obj_block_tl_state, curstate)->value;
					break;
				}
			}
			for (IntType i = IntType(0); i < idInt(block, tl_rotation_state_amount); i++)
			{
				VarType curstate = idArr(block, tl_rotation_state).Value(i);
				if (array_contains(ObjType(obj_block_tl_state, curstate)->state_id, stateid))
				{
					self->rotation = ObjType(obj_block_tl_state, curstate)->value;
					break;
				}
			}
			self->position[X_] += ObjType(obj_builder_thread, self.otherId)->build_pos_x * block_size_;
			self->position[Y_] += ObjType(obj_builder_thread, self.otherId)->build_pos_y * block_size_;
			self->position[Z_] += ObjType(obj_builder_thread, self.otherId)->build_pos_z * block_size_;
			self->variant = block_get_state_id_value(block, stateid, /*"variant"*/ STR(813));
			return self->id;
		}
		
		return IntType(0);
	}
	
	IntType block_load(VarType map, IntType typemap)
	{
		withOne (obj_block, (new obj_block)->id, noone)
		{
			self->block_id = array_length(VarType::CreateRef(global::block_objs));
			array_add(VarType::CreateRef(global::block_objs), self->id);
			if (is_string(DsMap(map).Value(/*"name"*/ STR(817))))
				self->name = DsMap(map).Value(/*"name"*/ STR(817));
			else
			{
				log({ /*"Missing parameter \"name\""*/ STR(818) });
				return null_;
			}
			
			if (dev_mode_debug_names && !text_exists(/*"block"*/ STR(4) + self->name))
				log({ /*"block/"*/ STR(819) + self->name + dev_mode_name_translation_message });
			if (is_string(DsMap(map).Value(/*"type"*/ STR(803))))
			{
				self->type = DsMap(map).Value(/*"type"*/ STR(803));
				self->set_script = asset_get_index(/*"block_set_"*/ STR(820) + self->type);
				self->generate_script = asset_get_index(/*"block_generate_"*/ STR(821) + self->type);
			}
			else
			{
				self->type = /*""*/ STR(0);
				self->set_script = null_;
				self->generate_script = null_;
			}
			
			if (is_string(DsMap(map).Value(/*"file"*/ STR(121))))
				self->filename = DsMap(map).Value(/*"file"*/ STR(121));
			else
				self->filename = /*""*/ STR(0);
			
			if (is_real(DsMap(map).Value(/*"emissive"*/ STR(822))))
				self->emissive = DsMap(map).Value(/*"emissive"*/ STR(822));
			else
				self->emissive = IntType(0);
			
			if (is_bool(DsMap(map).Value(/*"random_offset"*/ STR(823))))
				self->random_offset = DsMap(map).Value(/*"random_offset"*/ STR(823));
			else
				self->random_offset = false;
			
			if (is_bool(DsMap(map).Value(/*"random_offset_xz"*/ STR(824))))
				self->random_offset_xy = DsMap(map).Value(/*"random_offset_xz"*/ STR(824));
			else
				self->random_offset_xy = false;
			
			self->states_map = null_;
			self->state_id_amount = IntType(1);
			if (ds_map_valid(DsMap(map).Value(/*"states"*/ STR(825))))
			{
				self->states_map = ds_map_create();
				VarType curstate;
				curstate = ds_map_find_first((IntType)(DsMap(map).Value(/*"states"*/ STR(825))));
				while (!is_undefined(curstate))
				{
					if (dev_mode_debug_names && !text_exists(/*"blockstate"*/ STR(794) + curstate))
						log({ /*"block/state/"*/ STR(826) + curstate + dev_mode_name_translation_message });
					withOne (obj_block_state, (new obj_block_state)->id, self->id)
					{
						self->name = curstate;
						IntType valuelist = ds_map_find_value((IntType)(DsMap(map).Value(/*"states"*/ STR(825))), curstate);
						self->value_amount = ds_list_size(valuelist);
						self->value_map = ds_map_create();
						self->value_id = ObjType(obj_block, self.otherId)->state_id_amount;
						ObjType(obj_block, self.otherId)->state_id_amount *= self->value_amount;
						for (IntType v = IntType(0); v < self->value_amount; v++)
						{
							VarType curvalue = DsList(valuelist).Value(v);
							self->value_name[v] = curvalue;
							self->value_filename[v] = /*""*/ STR(0);
							self->value_file[v] = null_;
							self->value_emissive[v] = null_;
							self->value_random_offset[v] = null_;
							self->value_random_offset_xy[v] = null_;
							if (ds_map_valid(curvalue))
							{
								self->value_name[v] = DsMap(curvalue).Value(/*"value"*/ STR(827));
								if (is_string(DsMap(curvalue).Value(/*"file"*/ STR(121))))
									self->value_filename[v] = DsMap(curvalue).Value(/*"file"*/ STR(121));
								if (is_real(DsMap(curvalue).Value(/*"emissive"*/ STR(822))))
									self->value_emissive[v] = DsMap(curvalue).Value(/*"emissive"*/ STR(822));
								if (is_bool(DsMap(curvalue).Value(/*"random_offset"*/ STR(823))))
									self->value_random_offset[v] = DsMap(curvalue).Value(/*"random_offset"*/ STR(823));
								if (is_bool(DsMap(curvalue).Value(/*"random_offset_xz"*/ STR(824))))
									self->value_random_offset_xy[v] = DsMap(curvalue).Value(/*"random_offset_xz"*/ STR(824));
							}
							DsMap(self->value_map)[self->value_name.Value(v)] = v;
							if (dev_mode_debug_names && string_length(self->value_name.Value(v)) > IntType(3) && !text_exists(/*"blockstatevalue"*/ STR(5) + self->value_name.Value(v)))
								log({ /*"block/state/value/"*/ STR(828) + self->value_name.Value(v) + dev_mode_name_translation_message });
						}
						DsMap(ObjType(obj_block, self.otherId)->states_map)[curstate] = self->id;
						curstate = ds_map_find_next((IntType)(DsMap(map).Value(/*"states"*/ STR(825))), curstate);
					}
					
				}
				
			}
			if (self->filename != /*""*/ STR(0))
				self->file = block_load_state_file(global::load_assets_dir + mc_blockstates_directory + self->filename, self->id, ArrType());
			else
				self->file = null_;
			
			if (is_string(DsMap(map).Value(/*"default_state"*/ STR(829))))
				self->default_state = string_get_state_vars(DsMap(map).Value(/*"default_state"*/ STR(829)));
			else
				self->default_state = ArrType();
			
			self->default_state_id = block_get_state_id(self->id, self->default_state);
			if (is_real(DsMap(map).Value(/*"subsurface"*/ STR(130))))
				self->subsurface = DsMap(map).Value(/*"subsurface"*/ STR(130));
			else
				self->subsurface = IntType(0);
			
			VarType windmap = DsMap(map).Value(/*"wind"*/ STR(144));
			self->wind_axis = e_vertex_wave_NONE;
			self->wind_zmin = null_;
			if (ds_map_valid(windmap))
			{
				if (is_string(DsMap(windmap).Value(/*"axis"*/ STR(830))))
				{
					if (DsMap(windmap).Value(/*"axis"*/ STR(830)) == /*"y"*/ STR(831))
						self->wind_axis = e_vertex_wave_Z_ONLY;
					else
						self->wind_axis = e_vertex_wave_ALL;
					
				}
				if (is_real(DsMap(windmap).Value(/*"ymin"*/ STR(832))))
					self->wind_zmin = DsMap(windmap).Value(/*"ymin"*/ STR(832));
			}
			if (is_bool(DsMap(map).Value(/*"waterlogged"*/ STR(833))))
				self->waterlogged = DsMap(map).Value(/*"waterlogged"*/ STR(833));
			else
				self->waterlogged = false;
			
			if (is_bool(DsMap(map).Value(/*"require_models"*/ STR(834))))
				self->require_models = DsMap(map).Value(/*"require_models"*/ STR(834));
			else
				self->require_models = false;
			
			VarType timelinemap = DsMap(map).Value(/*"timeline"*/ STR(125));
			self->timeline = false;
			self->model_double = false;
			if (ds_map_valid(timelinemap))
				block_load_timeline(self, timelinemap, DsMap(typemap).Value(timelinemap));
			if (is_bool(DsMap(map).Value(/*"multithreaded"*/ STR(835))))
				self->multithreaded = DsMap(map).Value(/*"multithreaded"*/ STR(835));
			else
				self->multithreaded = true;
			
			VarType idmap = DsMap(map).Value(/*"id"*/ STR(86));
			self->mc_ids = ArrType();
			self->id_state_vars_map = null_;
			if (is_string(idmap))
			{
				self->mc_ids = ArrType::From({ string_replace(idmap, /*"minecraft:"*/ STR(836), /*""*/ STR(0)) });
				DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_id_map)[idmap] = self->id;
			}
			else
				if (ds_map_valid(idmap))
				{
					self->id_state_vars_map = ds_map_create();
					VarType key = ds_map_find_first((IntType)(idmap));
					while (!is_undefined(key))
					{
						array_add(VarType::CreateRef(self->mc_ids), string_replace(key, /*"minecraft:"*/ STR(836), /*""*/ STR(0)));
						DsMap(self->id_state_vars_map)[key] = string_get_state_vars(DsMap(idmap).Value(key));
						DsMap(ObjType(obj_minecraft_assets, global::mc_assets)->block_id_map)[key] = self->id;
						key = ds_map_find_next((IntType)(idmap), key);
					}
					
				}
			
			self->state_id_model_obj = null_;
			self->state_id_emissive = null_;
			self->state_id_random_offset = null_;
			self->state_id_random_offset_xy = null_;
			self->state_id_subsurface = null_;
			for (IntType sid = IntType(0); sid < self->state_id_amount; sid++)
			{
				VarType curfile, curemissive, curoffset, curoffsetxy;
				curfile = self->file;
				curemissive = self->emissive;
				curoffset = self->random_offset;
				curoffsetxy = self->random_offset_xy;
				if (self->states_map != null_)
				{
					VarType curstate = ds_map_find_first(self->states_map);
					while (!is_undefined(curstate))
					{
						withOne (Object, DsMap(self->states_map).Value(curstate), self->id)
						{
							RealType valid = mod(((IntType)(sid / sReal(value_id))), sReal(value_amount));
							if (sArr(value_filename).Value(valid) != /*""*/ STR(0))
							{
								if (sArr(value_file).Value(valid) == null_)
									sArr(value_file)[valid] = block_load_state_file(global::load_assets_dir + mc_blockstates_directory + sArr(value_filename).Value(valid), self.otherId, ArrType::From({ sVar(name), sVar(value_name).Value(valid) }));
								curfile = sArr(value_file).Value(valid);
							}
							if (sArr(value_emissive).Value(valid) != null_)
								curemissive = sArr(value_emissive).Value(valid);
							if (sArr(value_random_offset).Value(valid) != null_)
								curoffset = sArr(value_random_offset).Value(valid);
							if (sArr(value_random_offset_xy).Value(valid) != null_)
								curoffsetxy = sArr(value_random_offset_xy).Value(valid);
						}
						
						curstate = ds_map_find_next(self->states_map, curstate);
					}
					
				}
				self->state_id_model_obj[sid] = null_;
				withOne (Object, curfile, self->id)
				{
					VarType variant = DsMap(sInt(state_id_map)).Value(sid);
					if (is_undefined(variant))
						variant = DsMap(sInt(state_id_map)).Value(IntType(0));
					ObjType(obj_block, self.otherId)->state_id_model_obj[sid] = variant;
					ObjType(obj_block, self.otherId)->state_id_emissive[sid] = curemissive;
					ObjType(obj_block, self.otherId)->state_id_random_offset[sid] = curoffset;
					ObjType(obj_block, self.otherId)->state_id_random_offset_xy[sid] = curoffsetxy;
				}
				
			}
			return self->id;
		}
		
		return IntType(0);
	}
	
}
