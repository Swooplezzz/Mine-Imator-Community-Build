/*
	NOTE:
	This file was autogenerated by CppGen, changes may be overwritten and forever lost!
	Modify at your own risk!
	
	[ Generated on 2023.12.17 00:48:09 ]
*/

#include "Scripts.hpp"

namespace CppProject
{
	void project_save_timeline(Scope<obj_timeline> self)
	{
		json_save_object_start();
		json_save_var(/*"id"*/ STR(86), self->save_id);
		json_save_var(/*"type"*/ STR(803), DsList(global::tl_type_name_list).Value(self->type));
		json_save_var(/*"name"*/ STR(817), json_string_encode(self->name));
		json_save_var_save_id(/*"temp"*/ STR(2251), self->temp);
		json_save_var_nullable(/*"color_tag"*/ STR(2492), self->color_tag);
		json_save_var_bool(/*"hide"*/ STR(748), self->hide);
		json_save_var_bool(/*"lock"*/ STR(2493), self->lock);
		json_save_var_bool(/*"ghost"*/ STR(2494), self->ghost);
		json_save_var(/*"depth"*/ STR(637), self->depth);
		if (self->type == e_temp_type_BODYPART)
			json_save_var(/*"model_part_name"*/ STR(2495), json_string_encode(self->model_part_name));
		if (self->type == e_temp_type_TEXT)
			json_save_var(/*"text"*/ STR(104), json_string_encode(self->text));
		if (self->part_of != null_)
		{
			if (self->type == e_temp_type_SPECIAL_BLOCK)
			{
				json_save_object_start({ /*"model"*/ STR(8) });
				json_save_var(/*"name"*/ STR(817), self->model_name);
				json_save_var_state_vars(/*"state"*/ STR(1024), self->model_state);
				json_save_object_done();
			}
			else
				if (self->type == e_temp_type_BLOCK)
				{
					json_save_object_start({ /*"block"*/ STR(4) });
					json_save_var(/*"name"*/ STR(817), self->block_name);
					json_save_var_state_vars(/*"state"*/ STR(1024), self->block_state);
					json_save_object_done();
				}
			
			json_save_var_save_id(/*"part_of"*/ STR(2496), self->part_of);
			if (self->part_root != null_)
				json_save_var_save_id(/*"part_root"*/ STR(2497), self->part_root);
			if (self->pattern_type != /*""*/ STR(0) && self->pattern_base_color != null_)
			{
				json_save_var(/*"pattern_type"*/ STR(889), self->pattern_type);
				VarType color = ds_map_find_key(ObjType(obj_swatch, global::minecraft_swatch_dyes)->map, self->pattern_base_color);
				if (color != VarType())
					json_save_var(/*"pattern_base_color"*/ STR(2455), color);
				else
					json_save_var(/*"pattern_base_color"*/ STR(2455), /*"white"*/ STR(2456));
				
				if (array_length(VarType::CreateRef(self->pattern_pattern_list)) > IntType(0))
				{
					json_save_array_start({ /*"pattern_pattern_list"*/ STR(2459) });
					for (IntType p = IntType(0); p < array_length(VarType::CreateRef(self->pattern_pattern_list)); p++)
						json_save_array_value(self->pattern_pattern_list.Value(p));
					json_save_array_done();
				}
				if (array_length(VarType::CreateRef(self->pattern_color_list)) > IntType(0))
				{
					json_save_array_start({ /*"pattern_color_list"*/ STR(2460) });
					for (IntType c = IntType(0); c < array_length(VarType::CreateRef(self->pattern_color_list)); c++)
						json_save_array_value(ds_map_find_key(ObjType(obj_swatch, global::minecraft_swatch_dyes)->map, self->pattern_color_list.Value(c)));
					json_save_array_done();
				}
			}
		}
		if (self->part_list != null_)
		{
			json_save_array_start({ /*"parts"*/ STR(1836) });
			for (IntType p = IntType(0); p < ds_list_size(self->part_list); p++)
				json_save_array_value(save_id_get(DsList(self->part_list).Value(p)));
			json_save_array_done();
		}
		project_save_values(/*"default_values"*/ STR(2499), self->value_default, global::_app->value_default);
		json_save_object_start({ /*"keyframes"*/ STR(42) });
		for (IntType k = IntType(0); k < ds_list_size(self->keyframe_list); k++)
		{
			withOne (obj_keyframe, DsList(self->keyframe_list).Value(k), self->id)
			{
				keyframe_update_item_name(self);
				project_save_values(string(self->position), self->value, ObjType(obj_timeline, self.otherId)->value_default);
			}
			
		}
		json_save_object_done();
		if (self->parent != global::_app->id && idBool(self->parent, save))
			json_save_var_save_id(/*"parent"*/ STR(839), self->parent);
		else
			json_save_var_save_id(/*"parent"*/ STR(839), global::_app->id);
		
		json_save_var(/*"parent_tree_index"*/ STR(2500), ds_list_find_index(idInt(self->parent, tree_list), self->id));
		if (self->value_type.Value(e_value_type_HIERARCHY))
		{
			json_save_var_bool(/*"lock_bend"*/ STR(1857), self->lock_bend);
			json_save_var_bool(/*"tree_extend"*/ STR(2501), self->tree_extend);
			json_save_object_start({ /*"inherit"*/ STR(2502) });
			json_save_var_bool(/*"position"*/ STR(44), self->inherit_position);
			json_save_var_bool(/*"rotation"*/ STR(844), self->inherit_rotation);
			json_save_var_bool(/*"scale"*/ STR(887), self->inherit_scale);
			json_save_var_bool(/*"alpha"*/ STR(2334), self->inherit_alpha);
			json_save_var_bool(/*"color"*/ STR(918), self->inherit_color);
			json_save_var_bool(/*"texture"*/ STR(570), self->inherit_texture);
			json_save_var_bool(/*"surface"*/ STR(553), self->inherit_surface);
			json_save_var_bool(/*"subsurface"*/ STR(130), self->inherit_subsurface);
			json_save_var_bool(/*"visibility"*/ STR(2504), self->inherit_visibility);
			json_save_var_bool(/*"bend"*/ STR(1859), self->inherit_bend);
			json_save_var_bool(/*"rot_point"*/ STR(2503), self->inherit_rot_point);
			json_save_var_bool(/*"glow_color"*/ STR(2505), self->inherit_glow_color);
			json_save_var_bool(/*"select"*/ STR(2506), self->inherit_select);
			json_save_var_bool(/*"pose"*/ STR(2507), self->inherit_pose);
			json_save_object_done();
			json_save_var_bool(/*"scale_resize"*/ STR(2508), self->scale_resize);
		}
		if (self->value_type.Value(e_value_type_ROT_POINT))
		{
			json_save_var_bool(/*"rot_point_custom"*/ STR(2509), self->rot_point_custom);
			json_save_var_point3D(/*"rot_point"*/ STR(2503), self->rot_point);
		}
		if (self->value_type.Value(e_value_type_APPEARANCE))
		{
			json_save_var_bool(/*"backfaces"*/ STR(1858), self->backfaces);
			json_save_var_bool(/*"texture_blur"*/ STR(2510), self->texture_blur);
			json_save_var_bool(/*"texture_filtering"*/ STR(2423), self->texture_filtering);
			json_save_var_bool(/*"shadows"*/ STR(129), self->shadows);
			json_save_var_bool(/*"ssao"*/ STR(128), self->ssao);
			json_save_var_bool(/*"glow"*/ STR(133), self->glow);
			json_save_var_bool(/*"glow_texture"*/ STR(2511), self->glow_texture);
			json_save_var_bool(/*"only_render_glow"*/ STR(2512), self->only_render_glow);
			json_save_var(/*"glint_mode"*/ STR(2513), self->glint_mode);
			json_save_var(/*"glint_scale"*/ STR(2514), self->glint_scale);
			json_save_var(/*"glint_speed"*/ STR(2421), self->glint_speed);
			json_save_var(/*"glint_strength"*/ STR(2422), self->glint_strength);
			json_save_var_save_id(/*"glint_tex"*/ STR(2515), self->glint_tex);
			json_save_var_bool(/*"fog"*/ STR(143), self->fog);
			if (self->type == e_temp_type_SCENERY || self->type == e_temp_type_BLOCK || self->type == e_temp_type_PARTICLE_SPAWNER || self->type == e_temp_type_TEXT || type_is_shape(self->type))
			{
				json_save_var_bool(/*"wind"*/ STR(144), self->wind);
				json_save_var_bool(/*"wind_terrain"*/ STR(2516), self->wind_terrain);
			}
			json_save_var_bool(/*"hq_hiding"*/ STR(2517), self->hq_hiding);
			json_save_var_bool(/*"lq_hiding"*/ STR(2518), self->lq_hiding);
			json_save_var(/*"blend_mode"*/ STR(2519), self->blend_mode);
			json_save_var(/*"alpha_mode"*/ STR(2520), self->alpha_mode);
		}
		if (self->value_type.Value(e_value_type_PATH))
		{
			json_save_object_start({ /*"path"*/ STR(558) });
			json_save_var_bool(/*"smooth"*/ STR(2521), self->path_smooth);
			json_save_var_bool(/*"closed"*/ STR(2490), self->path_closed);
			json_save_var(/*"detail"*/ STR(2491), self->path_detail);
			json_save_var_bool(/*"shape_generate"*/ STR(2522), self->path_shape_generate);
			json_save_var(/*"shape_radius"*/ STR(2523), self->path_shape_radius);
			json_save_var(/*"shape_tex_length"*/ STR(2524), self->path_shape_tex_length);
			json_save_var_bool(/*"shape_invert"*/ STR(2525), self->path_shape_invert);
			json_save_var_bool(/*"shape_tube"*/ STR(2526), self->path_shape_tube);
			json_save_var(/*"shape_detail"*/ STR(2527), self->path_shape_detail);
			json_save_var_bool(/*"shape_smooth_segments"*/ STR(2528), self->path_shape_smooth_segments);
			json_save_var_bool(/*"shape_smooth_ring"*/ STR(2529), self->path_shape_smooth_ring);
			json_save_object_done();
		}
		json_save_object_done();
	}
	
	void project_save_values(StringType name, VarType arr, ArrType defarr)
	{
		json_save_object_start({ name });
		for (IntType v = IntType(0); v < e_value_amount; v++)
		{
			if (arr.Value(v) != defarr.Value(v))
			{
				if (tl_value_is_bool(v))
					json_save_var_bool(DsList(global::value_name_list).Value(v), arr.Value(v));
				else
					if (tl_value_is_color(v))
						json_save_var_color(DsList(global::value_name_list).Value(v), arr.Value(v));
					else
						if (tl_value_is_string(v))
							json_save_var(DsList(global::value_name_list).Value(v), json_string_encode(arr.Value(v)));
						else
							json_save_var(DsList(global::value_name_list).Value(v), tl_value_get_save_id(v, arr.Value(v)));
					
				
				
			}
		}
		json_save_object_done();
	}
	
	void project_startup(ScopeAny self)
	{
		global::load_queue = ds_priority_create();
		global::temp_edit = null_;
		global::ptype_edit = null_;
		global::tl_edit = null_;
		global::tl_edit_amount = IntType(0);
		global::res_edit = null_;
		global::axis_edit = X_;
		global::temp_creator = global::_app->id;
		global::res_creator = global::_app->id;
		sVar(save_id) = /*"root"*/ STR(2208);
		global::save_id_seed = random_get_seed();
		global::save_id_map = ds_map_create();
		global::shape_texture = texture_sprite(ID_spr_shape);
	}
	
	void ptype_copy(ScopeAny self, IntType to)
	{
		idVar(to, creator) = sVar(creator);
		if (self->subAssetId == ID_obj_particle_type)
			idInt(to, creator_index) = ds_list_find_index(idInt(sVar(creator), pc_type_list), self->id);
		else
			idInt(to, creator_index) = sInt(creator_index);
		
		idVar(to, name) = sVar(name);
		idVar(to, temp) = sVar(temp);
		idVar(to, text) = sVar(text);
		idVar(to, spawn_rate) = sVar(spawn_rate);
		idVar(to, sprite_tex) = sVar(sprite_tex);
		idVar(to, sprite_tex_image) = sVar(sprite_tex_image);
		idVar(to, sprite_template_tex) = sVar(sprite_template_tex);
		idVar(to, sprite_template) = sVar(sprite_template);
		idVar(to, sprite_template_reverse) = sVar(sprite_template_reverse);
		idVar(to, sprite_template_still_frame) = sVar(sprite_template_still_frame);
		idVar(to, sprite_template_random_frame) = sVar(sprite_template_random_frame);
		idVar(to, sprite_frame_width) = sVar(sprite_frame_width);
		idVar(to, sprite_frame_height) = sVar(sprite_frame_height);
		idVar(to, sprite_frame_start) = sVar(sprite_frame_start);
		idVar(to, sprite_frame_end) = sVar(sprite_frame_end);
		idVar(to, sprite_animation_speed) = sVar(sprite_animation_speed);
		idVar(to, sprite_animation_speed_israndom) = sVar(sprite_animation_speed_israndom);
		idVar(to, sprite_animation_speed_random_min) = sVar(sprite_animation_speed_random_min);
		idVar(to, sprite_animation_speed_random_max) = sVar(sprite_animation_speed_random_max);
		idVar(to, sprite_animation_onend) = sVar(sprite_animation_onend);
		idVar(to, angle_extend) = sVar(angle_extend);
		idVar(to, rot_extend) = sVar(rot_extend);
		idVar(to, spd_extend) = sVar(spd_extend);
		idVar(to, rot_spd_extend) = sVar(rot_spd_extend);
		idVar(to, angle) = array_copy_1d(sVar(angle));
		idVar(to, angle_israndom) = array_copy_1d(sVar(angle_israndom));
		idVar(to, angle_random_min) = array_copy_1d(sVar(angle_random_min));
		idVar(to, angle_random_max) = array_copy_1d(sVar(angle_random_max));
		idVar(to, angle_speed) = sVar(angle_speed);
		idVar(to, angle_speed_israndom) = sVar(angle_speed_israndom);
		idVar(to, angle_speed_random_min) = sVar(angle_speed_random_min);
		idVar(to, angle_speed_random_max) = sVar(angle_speed_random_max);
		idVar(to, angle_speed_add) = sVar(angle_speed_add);
		idVar(to, angle_speed_add_israndom) = sVar(angle_speed_add_israndom);
		idVar(to, angle_speed_add_random_min) = sVar(angle_speed_add_random_min);
		idVar(to, angle_speed_add_random_max) = sVar(angle_speed_add_random_max);
		idVar(to, angle_speed_mul) = sVar(angle_speed_mul);
		idVar(to, angle_speed_mul_israndom) = sVar(angle_speed_mul_israndom);
		idVar(to, angle_speed_mul_random_min) = sVar(angle_speed_mul_random_min);
		idVar(to, angle_speed_mul_random_max) = sVar(angle_speed_mul_random_max);
		idVar(to, spd) = array_copy_1d(sVar(spd));
		idVar(to, spd_israndom) = array_copy_1d(sVar(spd_israndom));
		idVar(to, spd_random_min) = array_copy_1d(sVar(spd_random_min));
		idVar(to, spd_random_max) = array_copy_1d(sVar(spd_random_max));
		idVar(to, spd_add) = array_copy_1d(sVar(spd_add));
		idVar(to, spd_add_israndom) = array_copy_1d(sVar(spd_add_israndom));
		idVar(to, spd_add_random_min) = array_copy_1d(sVar(spd_add_random_min));
		idVar(to, spd_add_random_max) = array_copy_1d(sVar(spd_add_random_max));
		idVar(to, spd_mul) = array_copy_1d(sVar(spd_mul));
		idVar(to, spd_mul_israndom) = array_copy_1d(sVar(spd_mul_israndom));
		idVar(to, spd_mul_random_min) = array_copy_1d(sVar(spd_mul_random_min));
		idVar(to, spd_mul_random_max) = array_copy_1d(sVar(spd_mul_random_max));
		idVar(to, rot) = array_copy_1d(sVar(rot));
		idVar(to, rot_israndom) = array_copy_1d(sVar(rot_israndom));
		idVar(to, rot_random_min) = array_copy_1d(sVar(rot_random_min));
		idVar(to, rot_random_max) = array_copy_1d(sVar(rot_random_max));
		idVar(to, rot_spd) = array_copy_1d(sVar(rot_spd));
		idVar(to, rot_spd_israndom) = array_copy_1d(sVar(rot_spd_israndom));
		idVar(to, rot_spd_random_min) = array_copy_1d(sVar(rot_spd_random_min));
		idVar(to, rot_spd_random_max) = array_copy_1d(sVar(rot_spd_random_max));
		idVar(to, rot_spd_add) = array_copy_1d(sVar(rot_spd_add));
		idVar(to, rot_spd_add_israndom) = array_copy_1d(sVar(rot_spd_add_israndom));
		idVar(to, rot_spd_add_random_min) = array_copy_1d(sVar(rot_spd_add_random_min));
		idVar(to, rot_spd_add_random_max) = array_copy_1d(sVar(rot_spd_add_random_max));
		idVar(to, rot_spd_mul) = array_copy_1d(sVar(rot_spd_mul));
		idVar(to, rot_spd_mul_israndom) = array_copy_1d(sVar(rot_spd_mul_israndom));
		idVar(to, rot_spd_mul_random_min) = array_copy_1d(sVar(rot_spd_mul_random_min));
		idVar(to, rot_spd_mul_random_max) = array_copy_1d(sVar(rot_spd_mul_random_max));
		idVar(to, sprite_angle) = sVar(sprite_angle);
		idVar(to, sprite_angle_israndom) = sVar(sprite_angle_israndom);
		idVar(to, sprite_angle_random_min) = sVar(sprite_angle_random_min);
		idVar(to, sprite_angle_random_max) = sVar(sprite_angle_random_max);
		idVar(to, sprite_angle_add) = sVar(sprite_angle_add);
		idVar(to, sprite_angle_add_israndom) = sVar(sprite_angle_add_israndom);
		idVar(to, sprite_angle_add_random_min) = sVar(sprite_angle_add_random_min);
		idVar(to, sprite_angle_add_random_max) = sVar(sprite_angle_add_random_max);
		idVar(to, scale) = sVar(scale);
		idVar(to, scale_israndom) = sVar(scale_israndom);
		idVar(to, scale_random_min) = sVar(scale_random_min);
		idVar(to, scale_random_max) = sVar(scale_random_max);
		idVar(to, scale_add) = sVar(scale_add);
		idVar(to, scale_add_israndom) = sVar(scale_add_israndom);
		idVar(to, scale_add_random_min) = sVar(scale_add_random_min);
		idVar(to, scale_add_random_max) = sVar(scale_add_random_max);
		idVar(to, alpha) = sVar(alpha);
		idVar(to, alpha_israndom) = sVar(alpha_israndom);
		idVar(to, alpha_random_min) = sVar(alpha_random_min);
		idVar(to, alpha_random_max) = sVar(alpha_random_max);
		idVar(to, alpha_add) = sVar(alpha_add);
		idVar(to, alpha_add_israndom) = sVar(alpha_add_israndom);
		idVar(to, alpha_add_random_min) = sVar(alpha_add_random_min);
		idVar(to, alpha_add_random_max) = sVar(alpha_add_random_max);
		idVar(to, color) = sVar(color);
		idVar(to, color_israndom) = sVar(color_israndom);
		idVar(to, color_random_start) = sVar(color_random_start);
		idVar(to, color_random_end) = sVar(color_random_end);
		idVar(to, color_mix_enabled) = sVar(color_mix_enabled);
		idVar(to, color_mix) = sVar(color_mix);
		idVar(to, color_mix_israndom) = sVar(color_mix_israndom);
		idVar(to, color_mix_random_start) = sVar(color_mix_random_start);
		idVar(to, color_mix_random_end) = sVar(color_mix_random_end);
		idVar(to, color_mix_time) = sVar(color_mix_time);
		idVar(to, color_mix_time_israndom) = sVar(color_mix_time_israndom);
		idVar(to, color_mix_time_random_min) = sVar(color_mix_time_random_min);
		idVar(to, color_mix_time_random_max) = sVar(color_mix_time_random_max);
		idVar(to, spawn_region) = sVar(spawn_region);
		idVar(to, bounding_box) = sVar(bounding_box);
		idVar(to, bounce) = sVar(bounce);
		idVar(to, bounce_factor) = sVar(bounce_factor);
		idVar(to, orbit) = sVar(orbit);
	}
	
	void ptype_event_create(Scope<obj_particle_type> self)
	{
		self->save_id = /*""*/ STR(0);
		self->save_id = save_id_create();
		self->creator = null_;
		self->name = /*""*/ STR(0);
		self->temp = particle_template;
		self->text = text_get({ /*"particleeditortypetextsample"*/ STR(2545) });
		self->spawn_rate = IntType(0);
		self->sprite_vbuffer_amount = IntType(0);
		self->sprite_vbuffer[IntType(0)] = null_;
		self->sprite_tex = null_;
		self->sprite_tex_image = IntType(0);
		self->sprite_template = /*"generic"*/ STR(2546);
		self->sprite_template_tex = global::mc_res;
		self->sprite_template_still_frame = false;
		self->sprite_template_random_frame = false;
		self->sprite_template_reverse = true;
		self->sprite_frame_width = IntType(8);
		self->sprite_frame_height = IntType(8);
		self->sprite_frame_start = IntType(7);
		self->sprite_frame_end = IntType(0);
		self->sprite_animation_speed = IntType(5);
		self->sprite_animation_speed_israndom = IntType(0);
		self->sprite_animation_speed_random_min = IntType(5);
		self->sprite_animation_speed_random_max = IntType(10);
		self->sprite_animation_onend = IntType(0);
		self->angle_collapse = true;
		self->spd_collapse = true;
		self->rot_collapse = true;
		self->rot_spd_collapse = true;
		self->angle_extend = false;
		self->spd_extend = false;
		self->rot_extend = false;
		self->rot_spd_extend = false;
		self->angle = vec3(IntType(0));
		self->angle_israndom = vec3(true);
		self->angle_random_min = vec3(IntType(0));
		self->angle_random_max = vec3(IntType(360));
		self->angle_speed = IntType(20);
		self->angle_speed_israndom = true;
		self->angle_speed_random_min = IntType(0);
		self->angle_speed_random_max = IntType(20);
		self->angle_speed_add = IntType(0);
		self->angle_speed_add_israndom = false;
		self->angle_speed_add_random_min = -IntType(1);
		self->angle_speed_add_random_max = IntType(1);
		self->angle_speed_mul = IntType(1);
		self->angle_speed_mul_israndom = false;
		self->angle_speed_mul_random_min = 0.75;
		self->angle_speed_mul_random_max = 0.9;
		self->spd = vec3(IntType(0));
		self->spd_israndom = vec3(false);
		self->spd_random_min = vec3(-IntType(20));
		self->spd_random_max = vec3(IntType(20));
		self->spd_add = vec3(IntType(0));
		self->spd_add_israndom = vec3(false);
		self->spd_add_random_min = vec3(-IntType(1));
		self->spd_add_random_max = vec3(IntType(1));
		self->spd_mul = vec3(IntType(1));
		self->spd_mul_israndom = vec3(false);
		self->spd_mul_random_min = vec3(0.75);
		self->spd_mul_random_max = vec3(0.9);
		self->rot = vec3(IntType(0));
		self->rot_israndom = vec3(true);
		self->rot_random_min = vec3(IntType(0));
		self->rot_random_max = vec3(IntType(360));
		self->rot_spd = vec3(IntType(0));
		self->rot_spd_israndom = vec3(true);
		self->rot_spd_random_min = vec3(-IntType(180));
		self->rot_spd_random_max = vec3(IntType(180));
		self->rot_spd_add = vec3(IntType(0));
		self->rot_spd_add_israndom = vec3(false);
		self->rot_spd_add_random_min = vec3(-IntType(10));
		self->rot_spd_add_random_max = vec3(IntType(10));
		self->rot_spd_mul = vec3(IntType(1));
		self->rot_spd_mul_israndom = vec3(false);
		self->rot_spd_mul_random_min = vec3(0.75);
		self->rot_spd_mul_random_max = vec3(0.9);
		self->sprite_angle = IntType(0);
		self->sprite_angle_israndom = false;
		self->sprite_angle_random_min = IntType(0);
		self->sprite_angle_random_max = IntType(360);
		self->sprite_angle_add = IntType(0);
		self->sprite_angle_add_israndom = false;
		self->sprite_angle_add_random_min = -IntType(90);
		self->sprite_angle_add_random_max = IntType(90);
		self->scale = IntType(1);
		self->scale_israndom = false;
		self->scale_random_min = 0.5;
		self->scale_random_max = IntType(2);
		self->scale_add = IntType(0);
		self->scale_add_israndom = false;
		self->scale_add_random_min = -0.2;
		self->scale_add_random_max = -0.1;
		self->alpha = IntType(1);
		self->alpha_israndom = false;
		self->alpha_random_min = IntType(0);
		self->alpha_random_max = IntType(1);
		self->alpha_add = IntType(0);
		self->alpha_add_israndom = false;
		self->alpha_add_random_min = -0.1;
		self->alpha_add_random_max = -0.05;
		self->color = c_white;
		self->color_israndom = false;
		self->color_random_start = c_gray;
		self->color_random_end = c_white;
		self->color_mix_enabled = false;
		self->color_mix = c_black;
		self->color_mix_israndom = false;
		self->color_mix_random_start = c_gray;
		self->color_mix_random_end = c_white;
		self->color_mix_time = IntType(3);
		self->color_mix_time_israndom = false;
		self->color_mix_time_random_min = IntType(1);
		self->color_mix_time_random_max = IntType(5);
		self->spawn_region = true;
		self->bounding_box = true;
		self->bounce = true;
		self->bounce_factor = 0.5;
		self->orbit = false;
		self->text_vbuffer = null_;
		self->text_texture = null_;
		self->text_string = /*""*/ STR(0);
		self->text_res = null_;
		self->text_3d = false;
	}
	
	void ptype_event_destroy(Scope<obj_particle_type> self)
	{
		ds_list_delete_value(idInt(self->creator, pc_type_list), self->id);
		if (global::temp_creator != global::_app->bench_settings)
		{
			idInt(self->sprite_tex, count)--;
			if (self->sprite_template_tex > 0)
				idInt(self->sprite_template_tex, count)--;
		}
		for (IntType m = IntType(0); m < self->sprite_vbuffer_amount; m++)
			vbuffer_destroy(self->sprite_vbuffer.Value(m));
		withAll (obj_particle, self->id)
			if (self->type == self.otherId)
				instance_destroy(ScopeAny(self));
		
		global::ptype_edit = sortlist_remove(global::_app->ptype_list, self->id);
	}
	
	void ptype_find_save_ids(Scope<obj_particle_type> self)
	{
		self->creator = save_id_find(self->creator);
		if (self->temp != particle_sheet && self->temp != particle_template)
			self->temp = save_id_find(self->temp);
		self->sprite_tex = save_id_find(self->sprite_tex);
		self->sprite_template_tex = save_id_find(self->sprite_template_tex);
	}
	
	void ptype_get_save_ids(Scope<obj_history_save> self)
	{
		self->creator = save_id_get(self->creator);
		if (self->temp != particle_sheet && self->temp != particle_template)
			self->temp = save_id_get(self->temp);
		self->sprite_tex = save_id_get(self->sprite_tex);
		self->sprite_template_tex = save_id_get(self->sprite_template_tex);
	}
	
	void ptype_update_sprite_vbuffers(ScopeAny self)
	{
		VarType res, tex;
		for (IntType m = IntType(0); m < sVar(sprite_vbuffer_amount); m++)
			vbuffer_destroy(sArr(sprite_vbuffer).Value(m));
		if (sVar(temp) == particle_sheet)
		{
			res = sVar(sprite_tex);
			if (!res_is_ready(res))
				res = global::mc_res;
			tex = idArr(res, particles_texture).Value(sVar(sprite_tex_image));
			RealType swid, shei, framesx;
			VarType fwid, fhei;
			swid = texture_width(tex);
			shei = texture_height(tex);
			fwid = min({ swid, sVar(sprite_frame_width) });
			fhei = min({ shei, sVar(sprite_frame_height) });
			framesx = (IntType)(swid / fwid);
			sVar(sprite_vbuffer_amount) = abs(sVar(sprite_frame_end) - sVar(sprite_frame_start)) + IntType(1);
			for (IntType m = IntType(0); m < sVar(sprite_vbuffer_amount); m++)
			{
				VarType frame;
				RealType tx1, ty1, tx2, ty2;
				frame = min({ sVar(sprite_frame_start), sVar(sprite_frame_end) }) + m;
				tx1 = ((mod(frame, framesx)) * fwid) / swid;
				ty1 = (((IntType)(frame / framesx)) * fhei) / shei;
				tx2 = tx1 + (RealType)fwid / swid;
				ty2 = ty1 + (RealType)fhei / shei;
				sArr(sprite_vbuffer)[m] = vbuffer_start();
				vertex_add({ (RealType)-fwid / 2.0, IntType(0), (RealType)fhei / 2.0, IntType(0), IntType(0), IntType(1), tx1, ty1 });
				vertex_add({ (RealType)fwid / 2.0, IntType(0), (RealType)fhei / 2.0, IntType(0), IntType(0), IntType(1), tx2, ty1 });
				vertex_add({ (RealType)fwid / 2.0, IntType(0), (RealType)-fhei / 2.0, IntType(0), IntType(0), IntType(1), tx2, ty2 });
				vertex_add({ (RealType)-fwid / 2.0, IntType(0), (RealType)fhei / 2.0, IntType(0), IntType(0), IntType(1), tx1, ty1 });
				vertex_add({ (RealType)fwid / 2.0, IntType(0), (RealType)-fhei / 2.0, IntType(0), IntType(0), IntType(1), tx2, ty2 });
				vertex_add({ (RealType)-fwid / 2.0, IntType(0), (RealType)-fhei / 2.0, IntType(0), IntType(0), IntType(1), tx1, ty2 });
				vbuffer_done();
			}
		}
		else
			if (sVar(temp) == particle_template)
			{
				res = sVar(sprite_template_tex);
				if (!res_is_ready(res))
					res = global::mc_res;
				VarType template_, size;
				template_ = DsMap(global::particle_template_map).Value(sVar(sprite_template));
				size = ObjType(obj_particle_template, template_)->size;
				sVar(sprite_vbuffer_amount) = ObjType(obj_particle_template, template_)->frames;
				for (IntType m = IntType(0); m < sVar(sprite_vbuffer_amount); m++)
				{
					VarType uvs, tx1, ty1, tx2, ty2;
					uvs = DsMap(idInt(res, particle_texture_uvs_map)).Value(DsList(ObjType(obj_particle_template, template_)->texture_list).Value(m));
					tx1 = uvs.Value(IntType(0));
					ty1 = uvs.Value(IntType(1));
					tx2 = uvs.Value(IntType(2)) + uvs.Value(IntType(0));
					ty2 = uvs.Value(IntType(3)) + uvs.Value(IntType(1));
					sArr(sprite_vbuffer)[m] = vbuffer_start();
					vertex_add({ (RealType)-size / 2.0, IntType(0), (RealType)size / 2.0, IntType(0), IntType(0), IntType(1), tx1, ty1 });
					vertex_add({ (RealType)size / 2.0, IntType(0), (RealType)size / 2.0, IntType(0), IntType(0), IntType(1), tx2, ty1 });
					vertex_add({ (RealType)size / 2.0, IntType(0), (RealType)-size / 2.0, IntType(0), IntType(0), IntType(1), tx2, ty2 });
					vertex_add({ (RealType)-size / 2.0, IntType(0), (RealType)size / 2.0, IntType(0), IntType(0), IntType(1), tx1, ty1 });
					vertex_add({ (RealType)size / 2.0, IntType(0), (RealType)-size / 2.0, IntType(0), IntType(0), IntType(1), tx2, ty2 });
					vertex_add({ (RealType)-size / 2.0, IntType(0), (RealType)-size / 2.0, IntType(0), IntType(0), IntType(1), tx1, ty2 });
					vbuffer_done();
				}
			}
		
	}
	
	RealType question(VarType text)
	{
		BoolType answer;
		window_set_caption(/*"Mine-imator"*/ STR(23));
		answer = show_question(text);
		window_set_caption(/*""*/ STR(0));
		return answer;
	}
	
	void recent_add(ScopeAny self)
	{
		sBool(recent_add_wait) = false;
		IntType obj = null_;
		for (IntType i = IntType(0); i < ds_list_size(sInt(recent_list)); i++)
		{
			withOne (Object, DsList(sInt(recent_list)).Value(i), global::_app->id)
			{
				if (sVar(filename) != global::_app->project_file)
					break;
				obj = self->id;
				ds_list_delete_value(global::_app->recent_list, self->id);
				if (sVar(thumbnail) != null_)
					texture_free(sVar(thumbnail));
			}
			
			if (obj != null_)
				break;
		}
		StringType thumbnailfn;
		VarType surf;
		thumbnailfn = sStr(project_folder) + /*"/thumbnail.png"*/ STR(2547);
		surf = null_;
		render_start({ surf, null_, sVar(recent_thumbnail_width), sVar(recent_thumbnail_height) });
		render_low(self);
		surf = render_done();
		surface_save_lib(surf, thumbnailfn);
		surface_free((IntType)(surf));
		if (obj == null_)
			obj = (new obj_recent)->id;
		withOne (obj_recent, obj, global::_app->id)
		{
			self->name = global::_app->project_name;
			self->author = global::_app->project_author;
			self->description = global::_app->project_description;
			self->thumbnail = texture_create(thumbnailfn);
			self->filename = global::_app->project_file;
			self->last_opened = date_current_datetime();
			self->pinned = false;
			ds_list_insert(global::_app->recent_list, IntType(0), self->id);
		}
		
		recent_update(self);
		recent_save();
	}
	
	void recent_event_create(Scope<obj_recent> self)
	{
		self->remove = false;
	}
	
	void recent_event_destroy(Scope<obj_recent> self)
	{
		ds_list_delete_value(global::_app->recent_list, self->id);
	}
	
	RealType recent_load(ScopeAny self)
	{
		if (!file_exists_lib(recent_file))
			return IntType(0);
		IntType recentmap = json_load({ recent_file });
		if (recentmap == VarType())
			return IntType(0);
		withAll (obj_recent, self->id)
			instance_destroy(ScopeAny(self));
		
		ds_list_clear(sInt(recent_list));
		VarType recentlist = DsMap(recentmap).Value(/*"list"*/ STR(1105));
		for (IntType i = IntType(0); i < ds_list_size((IntType)(recentlist)); i++)
		{
			VarType projectmap = DsList(recentlist).Value(i);
			if (ds_map_valid(projectmap))
			{
				IntType recentobj = (new obj_recent)->id;
				ObjType(obj_recent, recentobj)->name = value_get_string(DsMap(projectmap).Value(/*"name"*/ STR(817)), /*""*/ STR(0));
				ObjType(obj_recent, recentobj)->author = value_get_string(DsMap(projectmap).Value(/*"author"*/ STR(2358)), /*""*/ STR(0));
				ObjType(obj_recent, recentobj)->description = value_get_string(DsMap(projectmap).Value(/*"description"*/ STR(1839)), /*""*/ STR(0));
				ObjType(obj_recent, recentobj)->filename = value_get_string(DsMap(projectmap).Value(/*"filename"*/ STR(1261)), /*""*/ STR(0));
				ObjType(obj_recent, recentobj)->last_opened = value_get_real(DsMap(projectmap).Value(/*"last_opened"*/ STR(2548)), -IntType(1));
				ObjType(obj_recent, recentobj)->pinned = value_get_real(DsMap(projectmap).Value(/*"pinned"*/ STR(2549)), false);
				StringType thumbnailfn = filename_path(ObjType(obj_recent, recentobj)->filename) + /*"thumbnail.png"*/ STR(2550);
				if (file_exists_lib(thumbnailfn))
					ObjType(obj_recent, recentobj)->thumbnail = texture_create(thumbnailfn);
				else
					ObjType(obj_recent, recentobj)->thumbnail = null_;
				
				ds_list_add({ sInt(recent_list), recentobj });
			}
		}
		sReal(recent_list_amount) = ds_list_size(sInt(recent_list));
		recent_update(self);
		return 0.0;
	}
	
	void recent_save()
	{
		log({ /*"Updating recent list"*/ STR(2551) });
		json_save_start(recent_file);
		json_save_object_start();
		json_save_array_start({ /*"list"*/ STR(1105) });
		for (IntType i = IntType(0); i < ds_list_size(global::_app->recent_list); i++)
		{
			VarType recent = DsList(global::_app->recent_list).Value(i);
			json_save_object_start();
			json_save_var(/*"name"*/ STR(817), json_string_encode(idVar(recent, name)));
			json_save_var(/*"author"*/ STR(2358), json_string_encode(idVar(recent, author)));
			json_save_var(/*"description"*/ STR(1839), json_string_encode(idVar(recent, description)));
			json_save_var(/*"thumbnail"*/ STR(2552), idVar(recent, thumbnail));
			json_save_var(/*"filename"*/ STR(1261), json_string_encode(idVar(recent, filename)));
			json_save_var(/*"last_opened"*/ STR(2548), idVar(recent, last_opened));
			json_save_var_bool(/*"pinned"*/ STR(2549), idVar(recent, pinned));
			json_save_object_done();
		}
		json_save_array_done();
		json_save_object_done();
		json_save_done();
		debug({ /*"Saved recent list"*/ STR(2553) });
	}
	
	VarType recent_time_string(RealType time)
	{
		RealType currenttime = date_current_datetime();
		if (time < IntType(1))
			return text_get({ /*"recentlastopenednever"*/ STR(2554) });
		RealType seconds, minutes, hours, days, weeks;
		seconds = date_second_span(time, currenttime);
		minutes = date_minute_span(time, currenttime);
		hours = date_hour_span(time, currenttime);
		days = date_day_span(time, currenttime);
		weeks = date_week_span(time, currenttime);
		if (currenttime < time)
			return text_get({ /*"recentlastopenedfuture"*/ STR(2555) });
		if ((date_get_week(currenttime) != date_get_week(time)) && weeks < IntType(2))
			return text_get({ /*"recentlastopenedlastweek"*/ STR(2556) });
		if ((date_get_day(currenttime) != date_get_day(time)) && hours < IntType(24))
			return text_get({ /*"recentlastopenedyesterday"*/ STR(2557) });
		if (minutes < IntType(1))
			return text_get({ /*"recentlastopenedrecently"*/ STR(2558) });
		if (minutes < IntType(60))
			return text_get({ /*"recentlastopenedminutes"*/ STR(2559), floor(minutes) });
		if (hours < IntType(24))
			return text_get({ /*"recentlastopenedhours"*/ STR(2560), floor(hours) });
		if (days < IntType(7))
			return text_get({ /*"recentlastopeneddays"*/ STR(2561), floor(days) });
		return text_get({ /*"recentlastopeneddate"*/ STR(2562), date_get_day(time), date_get_month(time), date_get_year(time) });
	}
	
	void recent_update(ScopeAny self)
	{
		IntType pinnedlist = ds_list_create();
		IntType unpinnedlist = ds_list_create();
		IntType itemslist = ds_list_create();
		ds_list_copy(itemslist, sInt(recent_list));
		for (IntType i = IntType(0); i < ds_list_size(itemslist); i++)
		{
			VarType item = DsList(itemslist).Value(i);
			if (idBool(item, remove))
			{
				ds_list_delete(sInt(recent_list), i);
				instance_destroy(self, { item });
				continue;
			}
			if (idVar(item, pinned) > 0)
				ds_list_add({ pinnedlist, item });
			else
				ds_list_add({ unpinnedlist, item });
			
		}
		ds_list_clear(sInt(recent_list_display));
		recent_update_sort(self, pinnedlist);
		recent_update_sort(self, unpinnedlist);
		for (IntType i = IntType(0); i < ds_list_size(pinnedlist); i++)
			ds_list_add({ sInt(recent_list_display), DsList(pinnedlist).Value(i) });
		for (IntType i = IntType(0); i < ds_list_size(unpinnedlist); i++)
			ds_list_add({ sInt(recent_list_display), DsList(unpinnedlist).Value(i) });
		sReal(recent_list_amount) = ds_list_size(sInt(recent_list_display));
		ds_list_destroy(pinnedlist);
		ds_list_destroy(unpinnedlist);
		ds_list_destroy(itemslist);
	}
	
	void recent_update_sort(ScopeAny self, IntType list)
	{
		IntType listsize, datalist, prevlist, newlist;
		BoolType ascend, datesort;
		listsize = ds_list_size(list);
		ascend = (sVar(recent_sort_mode) == e_recent_sort_date_newest || sVar(recent_sort_mode) == e_recent_sort_name_az);
		datesort = (sVar(recent_sort_mode) == e_recent_sort_date_newest || sVar(recent_sort_mode) == e_recent_sort_date_oldest);
		datalist = ds_list_create();
		prevlist = ds_list_create();
		newlist = ds_list_create();
		if (datesort)
		{
			for (IntType i = IntType(0); i < listsize; i++)
				ds_list_add({ datalist, idVar(DsList(list).Value(i), last_opened) });
			ds_list_sort(datalist, !ascend);
			ds_list_copy(prevlist, list);
			for (IntType i = IntType(0); i < listsize; i++)
			{
				for (IntType j = IntType(0); j < ds_list_size(prevlist); j++)
				{
					if (DsList(datalist).Value(i) == idVar(DsList(prevlist).Value(j), last_opened))
					{
						ds_list_add({ newlist, DsList(prevlist).Value(j) });
						ds_list_delete(prevlist, j);
						break;
					}
				}
			}
		}
		else
		{
			for (IntType i = IntType(0); i < listsize; i++)
				ds_list_add({ datalist, idVar(DsList(list).Value(i), name) });
			ds_list_sort(datalist, ascend);
			ds_list_copy(prevlist, list);
			for (IntType i = IntType(0); i < listsize; i++)
			{
				for (IntType j = IntType(0); j < ds_list_size(prevlist); j++)
				{
					if (DsList(datalist).Value(i) == idVar(DsList(prevlist).Value(j), name))
					{
						ds_list_add({ newlist, DsList(prevlist).Value(j) });
						ds_list_delete(prevlist, j);
						break;
					}
				}
			}
		}
		
		ds_list_copy(list, newlist);
		ds_list_destroy(datalist);
		ds_list_destroy(prevlist);
		ds_list_destroy(newlist);
	}
	
	VarType render_done()
	{
		draw_set_color(global::render_prev_color);
		draw_set_alpha(global::render_prev_alpha);
		camera_apply(global::cam_window);
		return global::render_target;
	}
	
	void render_free()
	{
		surface_free((IntType)(global::render_surface.Value(IntType(0))));
		surface_free((IntType)(global::render_surface.Value(IntType(1))));
		surface_free((IntType)(global::render_surface.Value(IntType(2))));
		surface_free((IntType)(global::render_surface_hdr.Value(IntType(0))));
		surface_free((IntType)(global::render_surface_hdr.Value(IntType(1))));
		surface_free((IntType)(global::render_surface_hdr.Value(IntType(2))));
		surface_free((IntType)(global::render_surface_depth));
		surface_free((IntType)(global::render_surface_normal));
		surface_free((IntType)(global::render_surface_material));
		surface_free((IntType)(global::render_surface_emissive));
		surface_free((IntType)(global::render_surface_diffuse));
		surface_free((IntType)(global::render_surface_shadows));
		surface_free((IntType)(global::render_surface_specular));
		surface_free((IntType)(global::render_surface_lens));
		surface_free((IntType)(global::render_surface_sample_expo));
		surface_free((IntType)(global::render_surface_sample_dec));
		surface_free((IntType)(global::render_surface_sample_alpha));
		for (IntType i = IntType(0); i < global::render_cascades_count; i++)
			surface_free((IntType)(global::render_surface_sun_buffer.Value(i)));
		surface_free((IntType)(global::render_surface_spot_buffer));
		surface_free((IntType)(global::render_surface_point_buffer));
		surface_free((IntType)(global::render_surface_point_atlas_buffer));
	}
	
	void render_generate_dof_samples(VarType blades, VarType rotation, VarType ratio)
	{
		RealType rings, samples, rotoff;
		rings = IntType(7);
		samples = IntType(3);
		rotoff = (pi_ * IntType(2)) / (360.0 / 270.0);
		global::render_dof_samples = IntType(0);
		global::render_dof_weight_samples = IntType(0);
		global::render_dof_sample_amount = IntType(0);
		RealType disnoise, rotnoise;
		if (global::render_sample_current == IntType(0) || global::render_quality != e_view_mode_RENDER)
		{
			disnoise = IntType(0);
			rotnoise = IntType(0);
		}
		else
		{
			disnoise = random(1.0);
			rotnoise = random_range(0.0, pi_ * IntType(2));
		}
		
		for (RealType i = IntType(0); i < rings; i++)
		{
			RealType ringsamples = i * samples;
			RealType anglestep = (pi_ * IntType(2)) / ringsamples;
			RealType dis = frac((i / rings) + disnoise);
			for (IntType j = IntType(0); j < ringsamples; j++)
			{
				VecType offset = point2D_mul(point2D(cos((j * anglestep) + rotnoise), sin((j * anglestep) + rotnoise)), dis);
				global::render_dof_samples[global::render_dof_sample_amount * IntType(2)] = offset.Real(X_);
				global::render_dof_samples[global::render_dof_sample_amount * IntType(2) + IntType(1)] = offset.Real(Y_);
				global::render_dof_weight_samples[global::render_dof_sample_amount] = dis;
				global::render_dof_sample_amount++;
			}
		}
		for (IntType i = IntType(0); i < global::render_dof_sample_amount; i++)
		{
			VecType samplepos;
			samplepos = point2D(global::render_dof_samples.Value(i * IntType(2)), global::render_dof_samples.Value(i * IntType(2) + IntType(1)));
			if (blades > IntType(2))
			{
				RealType scale, anglestep;
				BoolType inblades;
				VecType prevcornerpos, cornerpos;
				scale = IntType(1);
				inblades = false;
				anglestep = ((pi_ * IntType(2)) / blades) * (blades - IntType(1));
				prevcornerpos = point2D(cos(anglestep + rotoff) * scale, sin(anglestep + rotoff) * scale);
				for (IntType j = IntType(0); j < blades; j++)
				{
					RealType anglestep = ((pi_ * IntType(2)) / blades) * j;
					cornerpos = point2D(cos(anglestep + rotoff) * scale, sin(anglestep + rotoff) * scale);
					if (point_in_triangle(samplepos.Real(X_), samplepos.Real(Y_), 0.0, 0.0, prevcornerpos.Real(X_), prevcornerpos.Real(Y_), cornerpos.Real(X_), cornerpos.Real(Y_)))
					{
						VecType midpoint;
						midpoint = point2D(lerp(prevcornerpos.Real(X_), cornerpos.Real(X_), 0.5), lerp(prevcornerpos.Real(Y_), cornerpos.Real(Y_), 0.5));
						global::render_dof_weight_samples[i] = clamp(vec2_dot(samplepos, midpoint) / vec2_dot(midpoint, midpoint), IntType(0), IntType(1));
						inblades = true;
					}
					prevcornerpos = cornerpos;
				}
				if (!inblades)
					global::render_dof_weight_samples[i] = IntType(0);
			}
			samplepos.Real(Y_) *= (IntType(1) - ratio);
			samplepos = uv_rotate(samplepos, -rotation, point2D(IntType(0), IntType(0)));
			global::render_dof_samples[i * IntType(2)] = samplepos.Real(X_);
			global::render_dof_samples[i * IntType(2) + IntType(1)] = samplepos.Real(Y_);
		}
	}
	
	ArrType render_generate_gaussian_kernel(RealType samples)
	{
		VarType prevrow, currentrow;
		ArrType kernel;
		RealType sum, largestnum;
		IntType largestindex;
		prevrow = array_create({ samples, IntType(0) });
		currentrow = array_create({ samples, IntType(0) });
		largestindex = IntType(0);
		largestnum = IntType(0);
		prevrow[IntType(0)] = IntType(1);
		prevrow[IntType(1)] = IntType(1);
		currentrow[IntType(0)] = IntType(1);
		currentrow[IntType(1)] = IntType(1);
		IntType i = IntType(3);
		for (; i <= samples; i++)
		{
			sum = IntType(0);
			for (IntType j = IntType(1); j < i; j++)
				currentrow[j] = prevrow.Value(j - IntType(1)) + prevrow.Value(j);
			for (IntType j = IntType(1); j < i; j++)
			{
				prevrow[j] = currentrow.Value(j);
				sum += currentrow.Value(j);
			}
		}
		for (IntType p = IntType(0); p < IntType(5); p++)
		{
			i = IntType(0);
			for (; i < samples; i++)
				currentrow[i] /= sum;
			i = IntType(0);
			sum = IntType(0);
			for (; i < samples; i++)
				sum += currentrow.Value(i);
		}
		i = IntType(0);
		for (; i < samples; i++)
		{
			if (currentrow.Value(i) > largestnum)
			{
				largestindex = i;
				largestnum = currentrow.Value(i);
			}
		}
		prevrow[IntType(0)] = largestnum;
		array_copy(VarType::CreateRef(prevrow), IntType(1), VarType::CreateRef(currentrow), IntType(0), largestindex);
		array_copy(VarType::CreateRef(prevrow), largestindex + IntType(1), VarType::CreateRef(currentrow), largestindex + IntType(1), (IntType)(samples - largestindex));
		kernel[IntType(0)] = prevrow.Value(IntType(0));
		kernel[IntType(1)] = IntType(0);
		i = IntType(1);
		for (; i < samples; i++)
		{
			kernel[i * IntType(2)] = prevrow.Value(i);
			RealType rad = ((i - IntType(1)) - (samples - IntType(1))) + ((samples - IntType(1)) / 2.0);
			if (rad >= IntType(0))
				rad++;
			rad /= (samples - IntType(1));
			kernel[(i * IntType(2)) + IntType(1)] = rad * IntType(2);
		}
		return kernel;
	}
	
	RealType render_generate_item(ScopeAny self, VarArgs argument)
	{
		IntType argument_count = argument.Size();
		VarType slot, res, is3d;
		if (argument_count == IntType(0))
		{
			slot = sVar(item_slot);
			res = sVar(item_tex);
			is3d = sVar(item_3d);
		}
		else
		{
			slot = argument[IntType(0)];
			res = argument[IntType(1)];
			is3d = argument[IntType(2)];
			if (sVar(item_slot) == slot && sVar(item_res) == res.Value(IntType(0)) && sVar(item_material_res) == res.Value(IntType(1)) && sVar(item_normal_res) == res.Value(IntType(2)) && sVar(item_3d) == is3d && sVar(item_custom_slot) == sVar(value).Value(e_value_CUSTOM_ITEM_SLOT))
				return IntType(0);
			sVar(item_slot) = slot;
			sVar(item_res) = res.Value(IntType(0));
			sVar(item_material_res) = res.Value(IntType(1));
			sVar(item_normal_res) = res.Value(IntType(2));
			sVar(item_3d) = is3d;
			sVar(item_custom_slot) = sVar(value).Value(e_value_CUSTOM_ITEM_SLOT);
			res = res.Value(IntType(0));
		}
		
		if (!res_is_ready(res))
			res = global::mc_res;
		if (sVar(item_vbuffer) > 0)
			vbuffer_destroy(sVar(item_vbuffer));
		sVar(item_vbuffer) = vbuffer_start();
		VecType texsize, texpos, slotpos, slotsize, slottexsize, slottex;
		if (idInt(res, item_sheet_texture) != null_)
		{
			texsize = vec2(texture_width(idInt(res, item_sheet_texture)), texture_height(idInt(res, item_sheet_texture)));
			slotpos = point2D(mod(slot, idVar(res, item_sheet_size).Value(X_)), (IntType)(slot / idVar(res, item_sheet_size).Value(X_)));
			slotsize = vec2_div(texsize, idVar(res, item_sheet_size));
			slotsize.Real(X_) = max({ IntType(1), slotsize.Real(X_) });
			slotsize.Real(Y_) = max({ IntType(1), slotsize.Real(Y_) });
			slottexsize = vec2_div(vec2(IntType(1)), idVar(res, item_sheet_size));
			slottex = point2D_mul(slotpos, slottexsize);
			texpos = point2D_mul(slotpos, slotsize);
		}
		else
		{
			texsize = vec2(texture_width(idVar(res, texture)), texture_height(idVar(res, texture)));
			slotpos = point2D(IntType(0), IntType(0));
			slotsize = texsize;
			slottexsize = point2D(IntType(1), IntType(1));
			slottex = point2D(IntType(0), IntType(0));
			texpos = point2D(IntType(0), IntType(0));
		}
		
		VecType pfix, slottexsizefix, slotsizefix;
		pfix = vec2_mul(vec2_div(vec2(IntType(1)), slotsize), vec2(1.0 / 256.0));
		slottexsizefix = point2D_sub(slottexsize, point2D_mul(pfix, slottexsize));
		slotsizefix = point2D_sub(slotsize, point2D_mul(pfix, slotsize));
		VecType size, scale;
		size = vec3(item_size, bool_to_float(is3d), item_size);
		if (slotsizefix.Real(X_) > slotsizefix.Real(Y_))
			size.Real(Z_) *= slotsizefix.Real(Y_) / slotsizefix.Real(X_);
		else
			if (slotsizefix.Real(Y_) > slotsizefix.Real(X_))
				size.Real(X_) *= slotsizefix.Real(X_) / slotsizefix.Real(Y_);
		
		scale = vec3_div(size, vec3(slotsizefix.Real(X_), size.Real(Y_), slotsizefix.Real(Y_)));
		VecType p1, p2, p3, p4;
		VecType t1, t2, t3, t4;
		p1 = point3D(IntType(0), size.Real(Y_), size.Real(Z_));
		p2 = point3D(size.Real(X_), size.Real(Y_), size.Real(Z_));
		p3 = point3D(size.Real(X_), size.Real(Y_), IntType(0));
		p4 = point3D(IntType(0), size.Real(Y_), IntType(0));
		t1 = slottex;
		t2 = point2D(slottex.Real(X_) + slottexsizefix.Real(X_), slottex.Real(Y_));
		t3 = point2D_add(slottex, slottexsizefix);
		t4 = point2D(slottex.Real(X_), slottex.Real(Y_) + slottexsizefix.Real(Y_));
		vbuffer_add_triangle({ p1, p2, p3, t1, t2, t3 });
		vbuffer_add_triangle({ p3, p4, p1, t3, t4, t1 });
		p1 = point3D(size.Real(X_), IntType(0), size.Real(Z_));
		p2 = point3D(IntType(0), IntType(0), size.Real(Z_));
		p3 = point3D(IntType(0), IntType(0), IntType(0));
		p4 = point3D(size.Real(X_), IntType(0), IntType(0));
		t1 = point2D(slottex.Real(X_) + slottexsizefix.Real(X_), slottex.Real(Y_));
		t2 = slottex;
		t3 = point2D(slottex.Real(X_), slottex.Real(Y_) + slottexsizefix.Real(Y_));
		t4 = point2D_add(slottex, slottexsizefix);
		vbuffer_add_triangle({ p1, p2, p3, t1, t2, t3 });
		vbuffer_add_triangle({ p3, p4, p1, t3, t4, t1 });
		if (is3d > 0)
		{
			VecType slotsizeceil;
			IntType surf;
			VarType tex;
			slotsizeceil = point2D(ceil(slotsize.Real(X_)), ceil(slotsize.Real(Y_)));
			surf = surface_create((IntType)(slotsizeceil.Real(X_)), (IntType)(slotsizeceil.Real(Y_)));
			if (idInt(res, item_sheet_texture) != null_)
				tex = idInt(res, item_sheet_texture);
			else
				tex = idVar(res, texture);
			
			draw_texture_start();
			surface_set_target(surf);
		{
			draw_clear_alpha(c_black, 0.0);
			draw_texture_part({ tex, IntType(0), IntType(0), floor(texpos.Real(X_)), floor(texpos.Real(Y_)), slotsizeceil.Real(X_), slotsizeceil.Real(Y_) });
		}
			surface_reset_target();
			draw_texture_done();
			VecType slotpixel = vec2_div(slottexsizefix, slotsizefix);
			vbuffer_add_pixels({ surface_get_alpha_array(surf), point3D(IntType(0), IntType(0), IntType(0)), size.Real(Z_), texpos, slotsizefix, slotpixel, scale });
			surface_free(surf);
		}
		vbuffer_done();
		return 0.0;
	}
	
}
