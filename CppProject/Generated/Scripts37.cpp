/*
	NOTE:
	This file was autogenerated by CppGen, changes may be overwritten and forever lost!
	Modify at your own risk!
	
	[ Generated on 2024.01.11 22:43:13 ]
*/

#include "Scripts.hpp"

namespace CppProject
{
	void minecraft_assets_load_biomes(IntType list, VarType map)
	{
		for (IntType b = IntType(0); b < ds_list_size((IntType)(map)); b++)
		{
			VarType biome = DsList(map).Value(b);
			IntType biomeid;
			withOne (obj_biome, (new obj_biome)->id, noone)
			{
				biomeid = self->id;
				self->name = DsMap(biome).Value(/*"name"*/ STR(820));
				self->group = value_get_real(DsMap(biome).Value(/*"group"*/ STR(1789)), false);
				self->txy = vec2(IntType(0));
				if (is_string(DsMap(biome).Value(/*"foliage"*/ STR(865))))
				{
					self->color_foliage = hex_to_color(DsMap(biome).Value(/*"foliage"*/ STR(865)));
					self->color_grass = self->color_foliage;
					self->hardcoded = true;
				}
				else
				{
					self->color_foliage = c_white;
					self->color_grass = c_white;
					self->txy = value_get_point2D(DsMap(biome).Value(/*"foliage"*/ STR(865)), vec2(IntType(0), IntType(0)));
					self->hardcoded = false;
				}
				
				if (is_string(DsMap(biome).Value(/*"grass"*/ STR(864))))
					self->color_grass = hex_to_color(DsMap(biome).Value(/*"grass"*/ STR(864)));
				if (is_string(DsMap(biome).Value(/*"water"*/ STR(818))))
					self->color_water = hex_to_color(DsMap(biome).Value(/*"water"*/ STR(818)));
				self->biome_base = null_;
				self->biome_variants = null_;
				self->variants_extend = false;
				if (ds_list_valid(DsMap(biome).Value(/*"variant"*/ STR(816))))
				{
					self->biome_variants = ds_list_create();
					VarType biomevariants = DsMap(biome).Value(/*"variant"*/ STR(816));
					for (IntType v = IntType(0); v < ds_list_size((IntType)(biomevariants)); v++)
					{
						VarType variant = DsList(biomevariants).Value(v);
						withOne (obj_biome, (new obj_biome)->id, self->id)
						{
							self->name = DsMap(variant).Value(/*"name"*/ STR(820));
							self->group = false;
							self->txy = array_copy_1d(ObjType(obj_biome, self.otherId)->txy);
							self->hardcoded = ObjType(obj_biome, self.otherId)->hardcoded;
							self->color_foliage = ObjType(obj_biome, self.otherId)->color_foliage;
							if (is_string(DsMap(variant).Value(/*"foliage"*/ STR(865))))
							{
								self->color_foliage = hex_to_color(DsMap(variant).Value(/*"foliage"*/ STR(865)));
								self->hardcoded = true;
							}
							else
								if (ds_list_valid(DsMap(variant).Value(/*"foliage"*/ STR(865))))
								{
									self->color_foliage = c_white;
									self->txy = value_get_point2D(DsMap(variant).Value(/*"foliage"*/ STR(865)), vec2(IntType(0), IntType(0)));
									self->hardcoded = false;
								}
							
							if (is_string(DsMap(variant).Value(/*"grass"*/ STR(864))))
								self->color_grass = hex_to_color(DsMap(variant).Value(/*"grass"*/ STR(864)));
							else
								self->color_grass = ObjType(obj_biome, self.otherId)->color_grass;
							
							if (is_string(DsMap(variant).Value(/*"water"*/ STR(818))))
								self->color_water = hex_to_color(DsMap(variant).Value(/*"water"*/ STR(818)));
							else
								self->color_water = ObjType(obj_biome, self.otherId)->color_water;
							
							self->biome_base = biomeid;
							ds_list_add({ ObjType(obj_biome, self->biome_base)->biome_variants, self->id });
						}
						
					}
				}
			}
			
			ds_list_add({ global::biome_list, biomeid });
		}
	}
	
	void minecraft_assets_load_legacy_block_data(Scope<obj_minecraft_assets> self, VarType curid, VarType map, IntType bitmask, RealType bitbase)
	{
		VarType key = ds_map_find_first((IntType)(map));
		while (!is_undefined(key))
		{
			switch (StringType(key).id)
			{
				case 1790: // 0x1
				{
					minecraft_assets_load_legacy_block_data(self, curid, DsMap(map).Value(key), IntType(1), IntType(1));
					break;
				}
				case 1791: // 0x2
				{
					minecraft_assets_load_legacy_block_data(self, curid, DsMap(map).Value(key), IntType(2), IntType(2));
					break;
				}
				case 1792: // 0x4
				{
					minecraft_assets_load_legacy_block_data(self, curid, DsMap(map).Value(key), IntType(4), IntType(4));
					break;
				}
				case 1793: // 0x8
				{
					minecraft_assets_load_legacy_block_data(self, curid, DsMap(map).Value(key), IntType(8), IntType(8));
					break;
				}
				case 1794: // 0x1+0x2
				{
					minecraft_assets_load_legacy_block_data(self, curid, DsMap(map).Value(key), IntType(3), IntType(1));
					break;
				}
				case 1795: // 0x1+0x2+0x4
				{
					minecraft_assets_load_legacy_block_data(self, curid, DsMap(map).Value(key), IntType(7), IntType(1));
					break;
				}
				case 1796: // 0x4+0x8
				{
					minecraft_assets_load_legacy_block_data(self, curid, DsMap(map).Value(key), IntType(12), IntType(4));
					break;
				}
				default:
				{
					VarType val, statevars, newid, block;
					StringType newidnomc;
					val = string_get_real(key);
					statevars = string_get_state_vars(DsMap(map).Value(key));
					newid = state_vars_get_value(statevars, /*"id"*/ STR(86));
					if (newid != null_)
						newidnomc = string_replace(newid, /*"minecraft:"*/ STR(839), /*""*/ STR(0));
					block = null_;
					if (is_string(newid) && !is_undefined(DsMap(self->block_id_map).Value(newid)))
						block = DsMap(self->block_id_map).Value(newid);
					if (bitmask > IntType(0))
					{
						for (IntType d = IntType(0); d < IntType(16); d++)
						{
							if (((IntType)d & (IntType)bitmask) / bitbase == val)
							{
								if (global::legacy_block_state_vars[curid][d] == null_)
									global::legacy_block_state_vars[curid][d] = ArrType();
								if (block != null_)
								{
									global::legacy_block_obj[curid][d] = block;
									if (ObjType(obj_block, block)->id_state_vars_map != null_ && !is_undefined(DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(newid)))
										state_vars_add(VarType::CreateRef(global::legacy_block_state_vars[curid][d]), DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(newid));
								}
								state_vars_add(VarType::CreateRef(global::legacy_block_state_vars[curid][d]), statevars);
								if (newid != null_)
									global::legacy_block_mc_id[curid][d] = newidnomc;
							}
						}
					}
					else
					{
						if (global::legacy_block_state_vars[curid][val] == null_)
							global::legacy_block_state_vars[curid][val] = ArrType();
						if (block != null_)
						{
							global::legacy_block_obj[curid][val] = block;
							if (ObjType(obj_block, block)->id_state_vars_map != null_ && !is_undefined(DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(newid)))
								state_vars_add(VarType::CreateRef(global::legacy_block_state_vars[curid][val]), DsMap(ObjType(obj_block, block)->id_state_vars_map).Value(newid));
						}
						state_vars_add(VarType::CreateRef(global::legacy_block_state_vars[curid][val]), statevars);
						if (newid != null_)
							global::legacy_block_mc_id[curid][val] = newidnomc;
					}
					
					break;
				}
			}
			
			key = ds_map_find_next((IntType)(map), key);
		}
		
	}
	
	void minecraft_assets_load_particles(VarType particlelist)
	{
		ArrType letterlist = ArrType::From({ /*"a"*/ STR(1797), /*"b"*/ STR(1798), /*"c"*/ STR(1799), /*"d"*/ STR(1800), /*"e"*/ STR(1257), /*"f"*/ STR(1258), /*"g"*/ STR(1801), /*"h"*/ STR(1802), /*"i"*/ STR(1803), /*"j"*/ STR(1804), /*"k"*/ STR(1805), /*"l"*/ STR(1806), /*"m"*/ STR(1807), /*"n"*/ STR(1259), /*"o"*/ STR(1808), /*"p"*/ STR(1809), /*"q"*/ STR(1810), /*"r"*/ STR(1811), /*"s"*/ STR(1812), /*"t"*/ STR(1260), /*"u"*/ STR(1261), /*"v"*/ STR(1813), /*"w"*/ STR(1814), /*"x"*/ STR(851), /*"y"*/ STR(834), /*"z"*/ STR(852) });
		for (IntType i = IntType(0); i < ds_list_size((IntType)(particlelist)); i++)
		{
			VarType tempmap;
			IntType ptemp;
			tempmap = DsList(particlelist).Value(i);
			ptemp = (new obj_particle_template)->id;
			ObjType(obj_particle_template, ptemp)->name = DsMap(tempmap).Value(/*"name"*/ STR(820));
			ObjType(obj_particle_template, ptemp)->texture_name = DsMap(tempmap).Value(/*"texture"*/ STR(573));
			if (!is_undefined(DsMap(tempmap).Value(/*"frames"*/ STR(1815))))
			{
				ObjType(obj_particle_template, ptemp)->frames = DsMap(tempmap).Value(/*"frames"*/ STR(1815));
				ObjType(obj_particle_template, ptemp)->animated = true;
			}
			else
			{
				ObjType(obj_particle_template, ptemp)->frames = IntType(1);
				ObjType(obj_particle_template, ptemp)->animated = false;
			}
			
			ObjType(obj_particle_template, ptemp)->size = value_get_real(DsMap(tempmap).Value(/*"size"*/ STR(1020)), IntType(8));
			ObjType(obj_particle_template, ptemp)->letter_suffix = value_get_real(DsMap(tempmap).Value(/*"letter_suffix"*/ STR(1816)), false);
			ObjType(obj_particle_template, ptemp)->texture_list = ds_list_create();
			if (ObjType(obj_particle_template, ptemp)->animated)
			{
				for (IntType j = IntType(0); j < ObjType(obj_particle_template, ptemp)->frames; j++)
				{
					if (ObjType(obj_particle_template, ptemp)->letter_suffix > 0)
						ds_list_add({ ObjType(obj_particle_template, ptemp)->texture_list, ObjType(obj_particle_template, ptemp)->texture_name + /*"_"*/ STR(1153) + letterlist.Value(j) });
					else
						ds_list_add({ ObjType(obj_particle_template, ptemp)->texture_list, ObjType(obj_particle_template, ptemp)->texture_name + /*"_"*/ STR(1153) + string(j) });
					
				}
			}
			else
			{
				ds_list_add({ ObjType(obj_particle_template, ptemp)->texture_list, ObjType(obj_particle_template, ptemp)->texture_name });
			}
			
			ds_list_add({ global::particle_template_list, ptemp });
			ds_map_add(global::particle_template_map, ObjType(obj_particle_template, ptemp)->name, ptemp);
		}
	}
	
	BoolType minecraft_assets_load_startup(ScopeAny self)
	{
		global::mc_assets = (new obj_minecraft_assets)->id;
		global::mc_builder = (new obj_builder)->id;
		global::mc_res = (new obj_resource)->id;
		sStr(window_state) = /*"load_assets"*/ STR(83);
		global::load_assets_stage = /*"unzip"*/ STR(1319);
		global::load_assets_progress = IntType(0);
		global::load_assets_map = null_;
		global::load_assets_type_map = null_;
		global::load_assets_block_index = IntType(0);
		window_set_size(IntType(740), IntType(450));
		sArr(alarm)[IntType(0)] = IntType(1);
		global::pattern_update = ArrType();
		global::armor_update = ArrType();
		withOne (obj_resource, global::mc_res, self->id)
		{
			self->save_id = /*"default"*/ STR(102);
			self->type = e_res_type_PACK;
			self->display_name = /*"Minecraft"*/ STR(1817);
			self->font_minecraft = true;
			self->font = new_minecraft_font(self);
			self->font_preview = self->font;
			self->font_no_aa = self->font;
			self->material_format = e_material_FORMAT_NONE;
		}
		
		if (!minecraft_assets_load_startup_version())
		{
			log({ /*"Could not load "*/ STR(1818) + string(global::_app->setting_minecraft_assets_version) + /*" assets. Resetting to default"*/ STR(1819), minecraft_version });
			global::_app->setting_minecraft_assets_version = minecraft_version;
			if (!minecraft_assets_load_startup_version())
				return false;
		}
		global::load_assets_splash = null_;
		global::load_assets_credits = /*""*/ STR(0);
		if (file_exists_lib(splash_directory + /*"splashes.json"*/ STR(1820)))
		{
			IntType map;
			VarType splashlist, splash;
			StringType splashfile;
			map = json_load({ splash_directory + /*"splashes.json"*/ STR(1820) });
			splashlist = DsMap(map).Value(/*"splashes"*/ STR(1821));
			splash = DsList(splashlist).Value(irandom((IntType)(ds_list_size((IntType)(splashlist)) - IntType(1))));
			splashfile = splash_directory + DsMap(splash).Value(/*"file"*/ STR(121));
			if (file_exists_lib(splashfile))
			{
				global::load_assets_splash = sprite_add(splashfile, IntType(0), IntType(0), IntType(0), IntType(0), IntType(0));
				global::load_assets_credits = DsMap(splash).Value(/*"credits"*/ STR(1822));
			}
		}
		return true;
	}
	
	BoolType minecraft_assets_load_startup_version()
	{
		StringType version = global::_app->setting_minecraft_assets_version;
		log({ /*"Loading Minecraft assets version"*/ STR(1823), version });
		global::load_assets_file = minecraft_directory + version + /*".midata"*/ STR(100);
		global::load_assets_zip_file = minecraft_directory + version + /*".zip"*/ STR(7);
		if (!file_exists_lib(global::load_assets_file))
		{
			log({ /*"Could not find Minecraft assets file"*/ STR(1824), global::load_assets_file });
			return false;
		}
		if (!file_exists_lib(global::load_assets_zip_file))
		{
			log({ /*"Could not find Minecraft assets archive"*/ STR(1825), global::load_assets_zip_file });
			return false;
		}
		global::load_assets_type_map = ds_int_map_create();
		global::load_assets_map = json_load({ global::load_assets_file, global::load_assets_type_map });
		if (!ds_map_valid(global::load_assets_map))
		{
			log({ /*"Could not parse JSON"*/ STR(1826), global::load_assets_file });
			ds_map_destroy(global::load_assets_type_map);
			return false;
		}
		VarType format = DsMap(global::load_assets_map).Value(/*"format"*/ STR(92));
		if (!is_real(format))
			format = e_minecraft_assets_FORMAT_110_PRE_1;
		if (format != minecraft_assets_format)
		{
			log({ /*"Unsupported archive, format"*/ STR(1827), format });
			return false;
		}
		VarType patch = DsMap(global::load_assets_map).Value(/*"patch"*/ STR(1828));
		if (!is_real(patch))
			patch = IntType(1);
		global::load_assets_startup_dir = mc_file_directory + version + (patch > IntType(1) ? /*"_"*/ STR(1153) + string(patch) : /*""*/ STR(0)) + /*"/"*/ STR(20);
		global::load_assets_dir = global::load_assets_startup_dir;
		global::load_assets_state_file_map = ds_string_map_create();
		global::load_assets_model_file_map = ds_map_create();
		return true;
	}
	
	BoolType minecraft_assets_reload()
	{
		StringType fname = minecraft_directory + minecraft_version + /*".midata"*/ STR(100);
		log({ /*"Reloading models"*/ STR(1829) });
		IntType typemap, map;
		typemap = ds_int_map_create();
		map = json_load({ fname, typemap });
		if (!ds_map_valid(map))
		{
			log({ /*"Could not parse JSON"*/ STR(1826), fname });
			ds_map_destroy(typemap);
			return false;
		}
		global::load_assets_model_file_map = ds_map_create();
		withOne (obj_minecraft_assets, global::mc_assets, noone)
		{
			ds_map_clear(self->model_name_map);
			ds_list_clear(self->char_list);
			ds_list_clear(self->special_block_list);
			VarType characterslist = DsMap(map).Value(/*"characters"*/ STR(1764));
			if (is_undefined(characterslist))
			{
				log({ /*"No character list found"*/ STR(1765) });
				break;
			}
			for (IntType i = IntType(0); i < ds_list_size((IntType)(characterslist)); i++)
			{
				IntType model = model_load(DsList(characterslist).Value(i), global::load_assets_dir + mc_character_directory);
				if (!(model > 0))
				{
					log({ /*"Could not load model"*/ STR(1766) });
					continue;
				}
				DsMap(self->model_name_map)[ObjType(obj_model, model)->name] = model;
				ds_list_add({ self->char_list, model });
			}
			VarType specialblockslist = DsMap(map).Value(/*"special_blocks"*/ STR(1768));
			if (is_undefined(specialblockslist))
			{
				log({ /*"No special block list found"*/ STR(1769) });
				break;
			}
			for (IntType i = IntType(0); i < ds_list_size((IntType)(specialblockslist)); i++)
			{
				IntType model = model_load(DsList(specialblockslist).Value(i), global::load_assets_dir + mc_special_block_directory);
				if (!(model > 0))
				{
					log({ /*"Could not load model"*/ STR(1766) });
					continue;
				}
				DsMap(self->model_name_map)[ObjType(obj_model, model)->name] = model;
				ds_list_add({ self->special_block_list, model });
			}
			VarType key = ds_map_find_first(global::load_assets_model_file_map);
			while (!is_undefined(key))
			{
				withOne (obj_block_load_model_file, DsMap(global::load_assets_model_file_map).Value(key), self->id)
					instance_destroy(ScopeAny(self));
				
				key = ds_map_find_next(global::load_assets_model_file_map, key);
			}
			
		}
		
		ds_map_destroy(global::load_assets_model_file_map);
		ds_map_destroy(map);
		ds_map_destroy(typemap);
		withAll (obj_template, noone)
			if (self->type == e_temp_type_CHARACTER || self->type == e_temp_type_SPECIAL_BLOCK)
				temp_update_model(ScopeAny(self));
		
		withAll (obj_timeline, noone)
			tl_update_scenery_part(ScopeAny(self));
		
		return false;
	}
	
	BoolType minecraft_assets_startup(ScopeAny self)
	{
		global::block_rendermodels = ArrType();
		global::block_objs = ArrType();
		global::player_head_vbuffer = null_;
		global::block_rendermodels[IntType(0)] = null_;
		global::block_objs[IntType(0)] = null_;
		if (sVar(setting_minecraft_assets_new_version) != /*""*/ STR(0))
		{
			sStr(new_assets_version) = sVar(setting_minecraft_assets_new_version).Str();
			sVar(new_assets_format) = sVar(setting_minecraft_assets_new_format);
			sVar(new_assets_changes) = sVar(setting_minecraft_assets_new_changes);
			sArr(new_assets_changes_lines) = string_split(sVar(new_assets_changes), /*"\n"*/ STR(711));
			sVar(new_assets_image) = sStr(setting_minecraft_assets_new_image);
			sInt(new_assets_scroll) = (new obj_scrollbar)->id;
			if (sVar(new_assets_image) != /*""*/ STR(0) && file_exists_lib(sVar(new_assets_image)))
				sInt(new_assets_image_texture) = texture_create(sVar(new_assets_image));
			else
				sInt(new_assets_image_texture) = null_;
			
			sStr(window_state) = /*"new_assets"*/ STR(82);
			sStr(new_assets_stage) = /*""*/ STR(0);
			sReal(new_assets_download_progress) = IntType(0);
			window_set_size(IntType(540), IntType(480));
			window_set_caption(/*"Mine-imator"*/ STR(23));
			sArr(alarm)[IntType(0)] = IntType(1);
		}
		else
			if (!minecraft_assets_load_startup(self))
			{
				error(/*"errorloadassets"*/ STR(101));
				return false;
			}
		
		return true;
	}
	
	VarType minecraft_asset_get_name(StringType type, VarType name)
	{
		if (string_digits(name) == name)
			return name;
		if (!text_exists(type + name))
			return (dev_mode_debug_names ? /*"?????? ["*/ STR(1830) + name + /*"]"*/ STR(1255) : string_format_snakecase(name));
		else
			return text_get({ type + name }) + (dev_mode_debug_names ? /*" ["*/ STR(1831) + name + /*"]"*/ STR(1255) : /*""*/ STR(0));
		
		return VarType();
	}
	
	VarType minecraft_get_color(VarType name)
	{
		ArrType keys = string_split(name, /*":"*/ STR(789));
		if (array_length(VarType::CreateRef(keys)) > IntType(1))
		{
			for (IntType s = IntType(0); s < array_length(VarType::CreateRef(global::minecraft_swatch_array)); s++)
			{
				VarType swatch = global::minecraft_swatch_array.Value(s);
				if (ObjType(obj_swatch, swatch)->name != keys.Value(IntType(0)))
					continue;
				for (IntType c = IntType(0); c < array_length(VarType::CreateRef(ObjType(obj_swatch, swatch)->colors)); c++)
				{
					if (keys.Value(IntType(1)) != ObjType(obj_swatch, swatch)->color_names.Value(c))
						continue;
					else
						return ObjType(obj_swatch, swatch)->colors.Value(c);
					
				}
			}
		}
		if (string_contains(name, /*"#"*/ STR(860)))
			return hex_to_color(name);
		else
			return c_white;
		
		return VarType();
	}
	
	IntType minecraft_get_swatch(StringType name)
	{
		for (IntType s = IntType(0); s < array_length(VarType::CreateRef(global::minecraft_swatch_array)); s++)
		{
			IntType swatch = global::minecraft_swatch_array.Value(s);
			if (ObjType(obj_swatch, swatch)->name == name)
				return swatch;
		}
		return null_;
	}
	
	IntType minecraft_mix_colors(ArrType arr)
	{
		RealType colors, totalMax, avgMax, maxOfAvg, gain;
		ArrType rgb, totalRgb, avgRgb;
		colors = array_length(VarType::CreateRef(arr));
		totalRgb = ArrType::From({ IntType(0), IntType(0), IntType(0) });
		totalMax = IntType(0);
		for (IntType i = IntType(0); i < colors; i++)
		{
			rgb = ArrType::From({ color_get_red((IntType)(arr.Value(i))), color_get_green((IntType)(arr.Value(i))), color_get_blue((IntType)(arr.Value(i))) });
			totalRgb[IntType(0)] += rgb.Value(IntType(0));
			totalRgb[IntType(1)] += rgb.Value(IntType(1));
			totalRgb[IntType(2)] += rgb.Value(IntType(2));
			totalMax += max({ rgb.Value(IntType(0)), rgb.Value(IntType(1)), rgb.Value(IntType(2)) });
		}
		avgRgb[IntType(0)] = totalRgb.Value(IntType(0)) / colors;
		avgRgb[IntType(1)] = totalRgb.Value(IntType(1)) / colors;
		avgRgb[IntType(2)] = totalRgb.Value(IntType(2)) / colors;
		avgMax = totalMax / colors;
		maxOfAvg = max({ avgRgb.Value(IntType(0)), avgRgb.Value(IntType(1)), avgRgb.Value(IntType(2)) });
		gain = avgMax / maxOfAvg;
		return make_color_rgb((IntType)(avgRgb.Value(IntType(0)) * gain), (IntType)(avgRgb.Value(IntType(1)) * gain), (IntType)(avgRgb.Value(IntType(2)) * gain));
	}
	
	void minecraft_update_armor()
	{
		if (array_length(VarType::CreateRef(global::armor_update)) > IntType(0) && global::_app->window_busy != /*"popup"*/ STR(1636) + ObjType(obj_popup, global::_app->popup_loading)->name)
		{
			VarType obj = null_;
			for (IntType i = IntType(0); i < array_length(VarType::CreateRef(global::armor_update)); i++)
			{
				obj = global::armor_update.Value(i);
				withOne (Object, obj, global::_app->id)
				{
					for (IntType j = IntType(0); j < IntType(4); j++)
					{
						if (sprite_exists(sArr(armor_skin_array).Value(j)))
							sprite_delete(sArr(armor_skin_array).Value(j));
					}
					VarType res;
					withOne (Object, obj, self->id)
						res = temp_get_model_texobj(self, null_);
					
					sArr(armor_skin_array) = minecraft_update_armor_generate(sArr(armor_array), res);
					if (obj == global::temp_edit)
						ObjType(obj_preview, global::_app->lib_preview)->update = true;
				}
				
			}
			global::armor_update = ArrType::From({});
		}
	}
	
	ArrType minecraft_update_armor_generate(ArrType data, VarType res)
	{
		ArrType skins = ArrType::From({ null_, null_, null_, null_ });
		if (res == null_ || !res_is_ready(res) || (idVar(res, type) != e_res_type_PACK && idVar(res, type) != e_res_type_PACK_UNZIPPED))
			res = global::mc_res;
		for (IntType i = IntType(0); i < IntType(4); i++)
		{
			RealType piece = i * IntType(4);
			VarType basemat, dye, trimpat, trimmat, basesprite;
			StringType layernum, basetex;
			basemat = data.Value(piece);
			if (basemat == /*"none"*/ STR(909))
				continue;
			dye = data.Value(piece + IntType(1));
			trimpat = data.Value(piece + IntType(2));
			trimmat = data.Value(piece + IntType(3));
			layernum = ((i == IntType(2)) ? /*"2"*/ STR(1137) : /*"1"*/ STR(1136));
			basetex = /*"models/armor/"*/ STR(1832) + basemat + /*"_layer_"*/ STR(1833) + layernum;
			basesprite = DsMap(idInt(res, model_texture_map)).Value(basetex);
			IntType armorsurf = surface_create(sprite_get_width((IntType)(basesprite)), sprite_get_height((IntType)(basesprite)));
			surface_set_target(armorsurf);
		{
			draw_clear_alpha(c_black, 0.0);
			if (basemat == /*"leather"*/ STR(1834))
			{
				draw_texture({ basesprite, IntType(0), IntType(0), IntType(1), IntType(1), dye, IntType(1) });
				draw_texture({ DsMap(idInt(res, model_texture_map)).Value(basetex + /*"_overlay"*/ STR(1835)), IntType(0), IntType(0) });
			}
			else
				draw_texture({ basesprite, IntType(0), IntType(0) });
			
		}
			surface_reset_target();
			if (trimpat != /*"none"*/ STR(909) && trimmat != /*"none"*/ STR(909))
			{
				VarType palette = DsMap(idInt(res, model_texture_map)).Value(/*"trims/color_palettes/"*/ STR(1836) + trimmat + (trimmat == basemat ? /*"_darker"*/ STR(1837) : /*""*/ STR(0)));
				surface_set_target(armorsurf);
			{
				gpu_set_texrepeat(false);
				global::render_shader_obj = DsMap(global::shader_map).Value(ID_shader_palette);
				withOne (Object, global::render_shader_obj, noone)
				{
					shader_set(sInt(shader));
					shader_palette_set(self, palette, DsMap(idInt(res, model_texture_map)).Value(/*"trims/color_palettes/trim_palette"*/ STR(1838)));
				}
				
				if (i == IntType(2))
					draw_sprite((IntType)(DsMap(idInt(res, model_texture_map)).Value(/*"trims/models/armor/"*/ STR(1839) + trimpat + /*"_leggings"*/ STR(1840))), IntType(0), IntType(0), IntType(0));
				else
					draw_sprite((IntType)(DsMap(idInt(res, model_texture_map)).Value(/*"trims/models/armor/"*/ STR(1839) + trimpat)), IntType(0), IntType(0), IntType(0));
				
				withOne (Object, global::render_shader_obj, noone)
					shader_reset();
				
				gpu_set_texrepeat(true);
			}
				surface_reset_target();
			}
			skins[i] = texture_surface(armorsurf);
			surface_free(armorsurf);
		}
		return skins;
	}
	
	void minecraft_update_patterns()
	{
		if (global::pattern_update != null_ && global::_app->window_busy != /*"popup"*/ STR(1636) + ObjType(obj_popup, global::_app->popup_loading)->name)
		{
			VarType obj = global::pattern_update;
			if (is_array(global::pattern_update))
			{
				for (IntType i = IntType(0); i < array_length(VarType::CreateRef(global::pattern_update)); i++)
				{
					obj = global::pattern_update.Value(i);
					withOne (Object, obj, global::_app->id)
					{
						if (sprite_exists(sInt(pattern_skin)))
							sprite_delete(sInt(pattern_skin));
						VarType res;
						withOne (Object, obj, self->id)
							res = temp_get_model_texobj(self, null_);
						
						sInt(pattern_skin) = minecraft_update_pattern_generate(sVar(model_name), sVar(pattern_base_color), sVar(pattern_pattern_list), sVar(pattern_color_list), res);
						if (obj == global::temp_edit)
							ObjType(obj_preview, global::_app->lib_preview)->update = true;
					}
					
				}
			}
			else
			{
				withOne (Object, obj, global::_app->id)
				{
					if (sprite_exists(sInt(pattern_skin)))
						sprite_delete(sInt(pattern_skin));
					VarType res;
					withOne (Object, obj, self->id)
						res = temp_get_model_texobj(self, null_);
					
					sInt(pattern_skin) = minecraft_update_pattern_generate(sVar(model_name), sVar(pattern_base_color), sVar(pattern_pattern_list), sVar(pattern_color_list), res);
					if (obj == global::temp_edit)
						ObjType(obj_preview, global::_app->lib_preview)->update = true;
				}
				
			}
			
			global::pattern_update = ArrType::From({});
		}
	}
	
	IntType minecraft_update_pattern_generate(VarType type, VarType color, VarType patternlist, VarType colorlist, VarType res)
	{
		RealType skinratio;
		ArrType maskarray;
		IntType patternskin;
		if (res == null_ || !res_is_ready(res))
			res = global::mc_res;
		StringType patternbase, patterndir;
		patternbase = (type == /*"banner"*/ STR(817) ? /*"entity/banner_base"*/ STR(1841) : /*"entity/shield_base"*/ STR(1842));
		patterndir = (type == /*"banner"*/ STR(817) ? /*"entity/banner/"*/ STR(1843) : /*"entity/shield/"*/ STR(1844));
		skinratio = IntType(1);
		maskarray = ArrType();
		if (idVar(res, type) == e_res_type_SKIN)
			return sprite_duplicate(idInt(res, model_texture));
		draw_set_color(c_white);
		draw_set_alpha(1.0);
		skinratio = max({ skinratio, ceil((RealType)sprite_get_width((IntType)(DsMap(idInt(res, model_texture_map)).Value(patternbase))) / sprite_get_width((IntType)(DsMap(ObjType(obj_resource, global::mc_res)->model_texture_map).Value(patternbase)))) });
		for (IntType i = IntType(0); i < ds_list_size(global::minecraft_pattern_list); i++)
		{
			VarType patternname = DsList(global::minecraft_pattern_list).Value(i);
			skinratio = max({ skinratio, ceil((RealType)sprite_get_width((IntType)(DsMap(idInt(res, model_texture_map)).Value(patterndir + patternname))) / sprite_get_width((IntType)(DsMap(ObjType(obj_resource, global::mc_res)->model_texture_map).Value(patterndir + patternname)))) });
		}
		global::shader_mask = (idVar(res, pack_format) < e_minecraft_pack_FORMAT_115);
		for (IntType i = IntType(0); i < ds_list_size(global::minecraft_pattern_list); i++)
		{
			VarType patternname = DsList(global::minecraft_pattern_list).Value(i);
			array_add(VarType::CreateRef(maskarray), texture_create_crop(DsMap(idInt(res, model_texture_map)).Value(patterndir + patternname), IntType(0), IntType(0), IntType(64) * skinratio, IntType(64) * skinratio));
		}
		global::shader_mask = false;
		IntType patternsurf = surface_create((IntType)(IntType(64) * skinratio), (IntType)(IntType(64) * skinratio));
		surface_set_target(patternsurf);
	{
		draw_clear_alpha(c_black, 0.0);
		draw_image({ DsMap(idInt(res, model_texture_map)).Value(patternbase), IntType(0), IntType(0), IntType(0) });
		draw_image({ maskarray.Value(IntType(0)), IntType(0), IntType(0), IntType(0), IntType(1), IntType(1), color, IntType(1) });
		for (IntType i = IntType(0); i < array_length(VarType::CreateRef(patternlist)); i++)
		{
			IntType pattern = ds_list_find_index(global::minecraft_pattern_list, patternlist.Value(i));
			draw_image({ maskarray.Value(pattern), IntType(0), IntType(0), IntType(0), IntType(1), IntType(1), colorlist.Value(i), IntType(1) });
		}
		gpu_set_blendmode_ext(bm_src_color, bm_one);
		draw_image({ maskarray.Value(IntType(0)), IntType(0), IntType(0), IntType(0), IntType(1), IntType(1), c_black, IntType(1) });
		gpu_set_blendmode(bm_normal);
	}
		surface_reset_target();
		patternskin = texture_surface(patternsurf);
		for (IntType i = IntType(0); i < array_length(VarType::CreateRef(maskarray)); i++)
			texture_free(maskarray.Value(i));
		surface_free(patternsurf);
		return patternskin;
	}
	
	BoolType missing_file(StringType fn)
	{
		log({ /*"Missing file"*/ STR(1845), fn });
		show_message(/*"The file "*/ STR(1846) + fn + /*" could not be found. If you are running from an archive, extract all the files and try again. If problems persist, re-install the program."*/ STR(1847));
		return false;
	}
	
	void model_file_event_destroy(Scope<obj_model_file> self)
	{
		if (self->part_list != null_)
		{
			for (IntType p = IntType(0); p < ds_list_size(self->part_list); p++)
				withOne (Object, DsList(self->part_list).Value(p), self->id)
					instance_destroy(self);
			
			ds_list_destroy(self->part_list);
		}
	}
	
	IntType model_file_load(StringType fname, IntType res)
	{
		if (!file_exists_lib(fname))
		{
			log({ /*"Could not find model file"*/ STR(840), fname });
			return null_;
		}
		IntType map = json_load({ fname });
		if (!ds_map_valid(map))
		{
			log({ /*"Could not parse model file"*/ STR(841), fname });
			return null_;
		}
		if (!is_string(DsMap(map).Value(/*"name"*/ STR(820))))
		{
			log({ /*"Missing parameter \"name\""*/ STR(821) });
			return null_;
		}
		if (!is_string(DsMap(map).Value(/*"texture"*/ STR(573))))
		{
			log({ /*"Missing parameter \"texture\""*/ STR(1848) });
			return null_;
		}
		if (!ds_list_valid(DsMap(map).Value(/*"texture_size"*/ STR(1849))))
		{
			log({ /*"Missing array \"texture_size\""*/ STR(1850) });
			return null_;
		}
		if (!ds_list_valid(DsMap(map).Value(/*"parts"*/ STR(1851))))
		{
			log({ /*"Missing array \"parts\""*/ STR(1852) });
			return null_;
		}
		withOne (obj_model_file, (new obj_model_file)->id, noone)
		{
			self->name = DsMap(map).Value(/*"name"*/ STR(820));
			if (res == null_ && dev_mode_debug_names && !text_exists(/*"model"*/ STR(8) + self->name))
				log({ /*"model/"*/ STR(1853) + self->name + dev_mode_name_translation_message });
			self->description = value_get_string(DsMap(map).Value(/*"description"*/ STR(1854)), /*""*/ STR(0));
			self->texture_name = DsMap(map).Value(/*"texture"*/ STR(573));
			self->texture_inherit = self->id;
			self->texture_material_inherit = self->id;
			self->texture_normal_inherit = self->id;
			if (res != null_)
				model_file_load_texture(self->texture_name, res);
			if (res != null_)
			{
				self->texture_material_name = value_get_string(DsMap(map).Value(/*"texture_material"*/ STR(1855)), /*""*/ STR(0));
				if (self->texture_material_name != /*""*/ STR(0))
					model_file_load_texture_material(self->texture_material_name, res);
				self->texture_normal_name = value_get_string(DsMap(map).Value(/*"texture_normal"*/ STR(1856)), /*""*/ STR(0));
				if (self->texture_normal_name != /*""*/ STR(0))
					model_file_load_tex_normal(self->texture_normal_name, res);
			}
			else
			{
				self->texture_material_name = self->texture_name;
				self->texture_normal_name = self->texture_name;
			}
			
			self->texture_size = value_get_point2D(DsMap(map).Value(/*"texture_size"*/ STR(1849)));
			RealType size = max({ self->texture_size.Value(X_), self->texture_size.Value(Y_) });
			self->texture_size = vec2(size, size);
			self->part_mixing_shapes = false;
			self->color_inherit = false;
			self->color_blend = c_white;
			self->color_alpha = IntType(1);
			self->color_emissive = IntType(0);
			self->color_mix = c_black;
			self->color_mix_percent = IntType(0);
			self->player_skin = value_get_real(DsMap(map).Value(/*"player_skin"*/ STR(1857)), false);
			self->scale = value_get_point3D(DsMap(map).Value(/*"scale"*/ STR(890)), vec3(IntType(1), IntType(1), IntType(1)));
			self->model_color = value_get_string(DsMap(map).Value(/*"model_color"*/ STR(1858)), /*"none"*/ STR(909));
			self->bounds_parts_start = point3D(no_limit, no_limit, no_limit);
			self->bounds_parts_end = point3D(-no_limit, -no_limit, -no_limit);
			self->has_3d_plane = false;
			self->floor_box_uvs = value_get_real(DsMap(map).Value(/*"floor_box_uvs"*/ STR(1859)), false);
			VarType partlist = DsMap(map).Value(/*"parts"*/ STR(1851));
			self->render_part_list = ds_list_create();
			self->file_part_list = ds_list_create();
			self->part_list = ds_list_create();
			for (IntType p = IntType(0); p < ds_list_size((IntType)(partlist)); p++)
			{
				VarType part = model_file_load_part(ScopeAny(self), DsList(partlist).Value(p), self->id, res, self->id);
				if (part == null_)
					return null_;
				if (part > IntType(0))
					ds_list_add({ self->part_list, part });
			}
			ds_map_destroy(map);
			return self->id;
		}
		
		return IntType(0);
	}
	
	VarType model_file_load_part(ScopeAny self, VarType map, IntType root, IntType res, IntType model)
	{
		if (!is_undefined(DsMap(map).Value(/*"visible"*/ STR(1860))) && !(DsMap(map).Value(/*"visible"*/ STR(1860)) > 0))
			return IntType(0);
		if (!is_string(DsMap(map).Value(/*"name"*/ STR(820))))
		{
			log({ /*"Missing parameter \"name\""*/ STR(821) });
			return null_;
		}
		if (!ds_list_valid(DsMap(map).Value(/*"position"*/ STR(44))))
		{
			log({ /*"Missing array \"position\""*/ STR(1861) });
			return null_;
		}
		for (IntType i = IntType(0); i < ds_list_size(ObjType(obj_model_file, root)->file_part_list); i++)
		{
			if (ObjType(obj_model_part, DsList(ObjType(obj_model_file, root)->file_part_list).Value(i))->name == DsMap(map).Value(/*"name"*/ STR(820)))
			{
				log({ /*"Duplicate part name found"*/ STR(1862), DsMap(map).Value(/*"name"*/ STR(820)) });
				return null_;
			}
		}
		withOne (obj_model_part, (new obj_model_part)->id, self->id)
		{
			self->name = DsMap(map).Value(/*"name"*/ STR(820));
			if (res == null_ && dev_mode_debug_names && !text_exists(/*"modelpart"*/ STR(779) + self->name))
				log({ /*"model/part/"*/ STR(1863) + self->name + dev_mode_name_translation_message });
			self->depth = value_get_real(DsMap(map).Value(/*"depth"*/ STR(640)), IntType(0));
			IntType pos;
			for (pos = IntType(0); pos < ds_list_size(ObjType(obj_model_file, model)->render_part_list); pos++)
				if (idVar(DsList(ObjType(obj_model_file, model)->render_part_list).Value(pos), depth) > self->depth)
					break;
			ds_list_insert(ObjType(obj_model_file, model)->render_part_list, pos, self->id);
			self->description = value_get_string(DsMap(map).Value(/*"description"*/ STR(1854)), /*""*/ STR(0));
			if (is_string(DsMap(map).Value(/*"texture"*/ STR(573))))
			{
				self->texture_name = DsMap(map).Value(/*"texture"*/ STR(573));
				self->texture_inherit = self->id;
				self->texture_material_inherit = self->id;
				self->texture_normal_inherit = self->id;
				if (!ds_list_valid(DsMap(map).Value(/*"texture_size"*/ STR(1849))))
				{
					log({ /*"Missing array \"texture_size\""*/ STR(1850) });
					return null_;
				}
				if (res != null_)
				{
					model_file_load_texture(self->texture_name, res);
					self->texture_material_name = value_get_string(DsMap(map).Value(/*"texture_material"*/ STR(1855)), /*""*/ STR(0));
					self->texture_normal_name = value_get_string(DsMap(map).Value(/*"texture_normal"*/ STR(1856)), /*""*/ STR(0));
					if (self->texture_material_name != /*""*/ STR(0))
						model_file_load_texture_material(self->texture_material_name, res);
					else
						self->texture_material_inherit = idInt(self.otherId, texture_material_inherit);
					
					if (self->texture_normal_name != /*""*/ STR(0))
						model_file_load_tex_normal(self->texture_normal_name, res);
					else
						self->texture_normal_inherit = idInt(self.otherId, texture_normal_inherit);
					
				}
				else
				{
					self->texture_material_name = self->texture_name;
					self->texture_normal_name = self->texture_name;
				}
				
				self->texture_size = value_get_point2D(DsMap(map).Value(/*"texture_size"*/ STR(1849)));
				RealType size = max({ self->texture_size.Value(X_), self->texture_size.Value(Y_) });
				self->texture_size = vec2(size, size);
			}
			else
			{
				self->texture_name = /*""*/ STR(0);
				self->texture_material_name = /*""*/ STR(0);
				self->texture_normal_name = /*""*/ STR(0);
				self->texture_inherit = idInt(self.otherId, texture_inherit);
				self->texture_material_inherit = idInt(self.otherId, texture_material_inherit);
				self->texture_normal_inherit = idInt(self.otherId, texture_normal_inherit);
				self->texture_size = idVar(self->texture_inherit, texture_size);
			}
			
			self->color_inherit = value_get_real(DsMap(map).Value(/*"color_inherit"*/ STR(1864)), true);
			self->color_blend = value_get_color(DsMap(map).Value(/*"color_blend"*/ STR(1865)), c_white);
			self->color_alpha = value_get_real(DsMap(map).Value(/*"color_alpha"*/ STR(1866)), IntType(1));
			if (is_real(/*"color_emissive"*/ STR(1867)))
				self->color_emissive = value_get_real(DsMap(map).Value(/*"color_emissive"*/ STR(1867)), IntType(0));
			else
				self->color_emissive = value_get_real(DsMap(map).Value(/*"color_brightness"*/ STR(1868)), IntType(0));
			
			self->color_mix = value_get_color(DsMap(map).Value(/*"color_mix"*/ STR(1869)), c_black);
			self->color_mix_percent = value_get_real(DsMap(map).Value(/*"color_mix_percent"*/ STR(1870)), IntType(0));
			self->part_mixing_shapes = false;
			if (self->color_inherit > 0)
			{
				self->color_blend = color_multiply(self->color_blend, idVar(self.otherId, color_blend));
				self->color_alpha *= idVar(self.otherId, color_alpha);
				self->color_emissive = clamp(self->color_emissive + idVar(self.otherId, color_emissive), IntType(0), IntType(1));
				self->color_mix = color_add(self->color_mix, idVar(self.otherId, color_mix));
				self->color_mix_percent = clamp(self->color_mix_percent + idVar(self.otherId, color_mix_percent), IntType(0), IntType(1));
			}
			if (self->color_mix_percent > IntType(0))
				self->part_mixing_shapes = true;
			self->position_noscale = value_get_point3D(DsMap(map).Value(/*"position"*/ STR(44)));
			self->position = point3D_mul(self->position_noscale, idVar(self.otherId, scale));
			self->rotation = value_get_point3D(DsMap(map).Value(/*"rotation"*/ STR(847)), vec3(IntType(0), IntType(0), IntType(0)));
			self->scale = value_get_point3D(DsMap(map).Value(/*"scale"*/ STR(890)), vec3(IntType(1), IntType(1), IntType(1)));
			self->scale = vec3_mul(self->scale, idVar(self.otherId, scale));
			self->floor_box_uvs = idVar(self.otherId, floor_box_uvs);
			self->show_position = value_get_real(DsMap(map).Value(/*"show_position"*/ STR(1871)), false);
			if (Obj(self.otherId)->subAssetId == ID_obj_model_part && idVar(self.otherId, locked) > 0)
				self->locked = true;
			else
				self->locked = value_get_real(DsMap(map).Value(/*"locked"*/ STR(942)), false);
			
			self->lock_bend = true;
			if (Obj(self.otherId)->subAssetId == ID_obj_model_part && idInt(self.otherId, bend_part) != null_)
			{
				if (is_bool(DsMap(map).Value(/*"lock_bend"*/ STR(1872))) || is_real(DsMap(map).Value(/*"lock_bend"*/ STR(1872))))
					self->lock_bend = DsMap(map).Value(/*"lock_bend"*/ STR(1872));
				if (self->lock_bend > 0)
				{
					switch ((IntType)idInt(self.otherId, bend_part))
					{
						case e_part_LEFT:
						case e_part_RIGHT:
						{
							self->position[X_] -= idVar(self.otherId, bend_offset);
							break;
						}
						case e_part_BACK:
						case e_part_FRONT:
						{
							self->position[Y_] -= idVar(self.otherId, bend_offset);
							break;
						}
						case e_part_LOWER:
						case e_part_UPPER:
						{
							self->position[Z_] -= idVar(self.otherId, bend_offset);
							break;
						}
					}
					
				}
			}
			self->backfaces = value_get_real(DsMap(map).Value(/*"backfaces"*/ STR(1873)), false);
			if (!is_undefined(DsMap(map).Value(/*"bend"*/ STR(1874))))
			{
				VarType bendmap = DsMap(map).Value(/*"bend"*/ STR(1874));
				self->bend_inherit = value_get_real(DsMap(bendmap).Value(/*"inherit_bend"*/ STR(1875)), false);
				if (!is_real(DsMap(bendmap).Value(/*"offset"*/ STR(1876))))
				{
					log({ /*"Missing parameter \"offset\""*/ STR(1877) });
					return null_;
				}
				self->bend_offset = DsMap(bendmap).Value(/*"offset"*/ STR(1876));
				self->bend_end_offset = value_get_real(DsMap(bendmap).Value(/*"end_offset"*/ STR(1878)), IntType(0));
				self->bend_size = value_get_real(DsMap(bendmap).Value(/*"size"*/ STR(1020)), null_);
				if (!is_string(DsMap(bendmap).Value(/*"part"*/ STR(904))))
				{
					log({ /*"Missing parameter \"part\""*/ STR(1879) });
					return null_;
				}
				switch (StringType(DsMap(bendmap).Value(/*"part"*/ STR(904))).id)
				{
					case 204: // right
					{
						self->bend_part = e_part_RIGHT;
						self->bend_offset *= self->scale.Value(X_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(X_);
						self->bend_pos_offset = point3D(self->bend_offset, IntType(0), IntType(0));
						break;
					}
					case 203: // left
					{
						self->bend_part = e_part_LEFT;
						self->bend_offset *= self->scale.Value(X_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(X_);
						self->bend_pos_offset = point3D(self->bend_offset, IntType(0), IntType(0));
						break;
					}
					case 889: // front
					{
						self->bend_part = e_part_FRONT;
						self->bend_offset *= self->scale.Value(Y_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(Y_);
						self->bend_pos_offset = point3D(IntType(0), self->bend_offset, IntType(0));
						break;
					}
					case 891: // back
					{
						self->bend_part = e_part_BACK;
						self->bend_offset *= self->scale.Value(Y_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(Y_);
						self->bend_pos_offset = point3D(IntType(0), self->bend_offset, IntType(0));
						break;
					}
					case 923: // upper
					{
						self->bend_part = e_part_UPPER;
						self->bend_offset *= self->scale.Value(Z_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(Z_);
						self->bend_pos_offset = point3D(IntType(0), IntType(0), self->bend_offset);
						break;
					}
					case 1880: // lower
					{
						self->bend_part = e_part_LOWER;
						self->bend_offset *= self->scale.Value(Z_);
						if (self->bend_size != null_)
							self->bend_size *= self->scale.Value(Z_);
						self->bend_pos_offset = point3D(IntType(0), IntType(0), self->bend_offset);
						break;
					}
					default:
						log({ /*"Invalid parameter \"part\""*/ STR(1881) });
						return null_;
				}
				
				self->bend_axis = ArrType::From({ false, false, false });
				ArrType axis = ArrType();
				if (is_string(DsMap(bendmap).Value(/*"axis"*/ STR(833))))
				{
					switch (StringType(DsMap(bendmap).Value(/*"axis"*/ STR(833))).id)
					{
						case 851: // x
						{
							self->bend_axis.Real(X_) = true;
							array_add(VarType::CreateRef(axis), X_);
							break;
						}
						case 852: // z
						{
							self->bend_axis.Real(Y_) = true;
							array_add(VarType::CreateRef(axis), Y_);
							break;
						}
						case 834: // y
						{
							self->bend_axis.Real(Z_) = true;
							array_add(VarType::CreateRef(axis), Z_);
							break;
						}
						default:
							log({ /*"Invalid parameter \"axis\""*/ STR(1882) });
							return null_;
					}
					
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"axis"*/ STR(833))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"axis"*/ STR(833)))); i++)
						{
							switch (StringType(ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"axis"*/ STR(833))), i)).id)
							{
								case 851: // x
								{
									self->bend_axis.Real(X_) = true;
									array_add(VarType::CreateRef(axis), X_);
									break;
								}
								case 852: // z
								{
									self->bend_axis.Real(Y_) = true;
									array_add(VarType::CreateRef(axis), Y_);
									break;
								}
								case 834: // y
								{
									self->bend_axis.Real(Z_) = true;
									array_add(VarType::CreateRef(axis), Z_);
									break;
								}
								default:
									log({ /*"Invalid parameter \"axis\""*/ STR(1882) });
									return null_;
							}
							
						}
					}
					else
					{
						log({ /*"Missing parameter \"axis\""*/ STR(1883) });
						return null_;
					}
				
				
				self->bend_direction_min = vec3(-IntType(180));
				if (is_real(DsMap(bendmap).Value(/*"direction_min"*/ STR(1884))) && array_length(VarType::CreateRef(axis)) == IntType(1))
				{
					self->bend_direction_min.Real(axis.Value(IntType(0))) = DsMap(bendmap).Value(/*"direction_min"*/ STR(1884));
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"direction_min"*/ STR(1884))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"direction_min"*/ STR(1884)))); i++)
							self->bend_direction_min.Real(axis.Value(i)) = ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"direction_min"*/ STR(1884))), i);
					}
				
				self->bend_direction_max = vec3(IntType(180));
				if (is_real(DsMap(bendmap).Value(/*"direction_max"*/ STR(1885))) && array_length(VarType::CreateRef(axis)) == IntType(1))
				{
					self->bend_direction_max.Real(axis.Value(IntType(0))) = DsMap(bendmap).Value(/*"direction_max"*/ STR(1885));
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"direction_max"*/ STR(1885))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"direction_max"*/ STR(1885)))); i++)
							self->bend_direction_max.Real(axis.Value(i)) = ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"direction_max"*/ STR(1885))), i);
					}
				
				self->bend_direction = ArrType::From({ IntType(0), IntType(0), IntType(0) });
				self->bend_direction_legacy = false;
				if (is_string(DsMap(bendmap).Value(/*"direction"*/ STR(931))))
				{
					switch (StringType(DsMap(bendmap).Value(/*"direction"*/ STR(931))).id)
					{
						case 1886: // forward
						{
							self->bend_direction.Real(axis.Value(IntType(0))) = e_bend_FORWARD;
							break;
						}
						case 1887: // backward
						{
							self->bend_direction.Real(axis.Value(IntType(0))) = e_bend_BACKWARD;
							break;
						}
						case 1888: // both
						{
							self->bend_direction.Real(axis.Value(IntType(0))) = e_bend_BOTH;
							break;
						}
						default:
							log({ /*"Invalid parameter \"direction\""*/ STR(1889) });
							return null_;
					}
					
					self->bend_direction_legacy = true;
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"direction"*/ STR(931))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"direction"*/ STR(931)))); i++)
						{
							switch (StringType(ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"direction"*/ STR(931))), i)).id)
							{
								case 1886: // forward
								{
									self->bend_direction.Real(axis.Value(i)) = e_bend_FORWARD;
									break;
								}
								case 1887: // backward
								{
									self->bend_direction.Real(axis.Value(i)) = e_bend_BACKWARD;
									break;
								}
								case 1888: // both
								{
									self->bend_direction.Real(axis.Value(i)) = e_bend_BOTH;
									break;
								}
								default:
									log({ /*"Invalid parameter \"direction\""*/ STR(1889) });
									return null_;
							}
							
							self->bend_direction_legacy = true;
						}
					}
				
				if ((is_real(DsMap(bendmap).Value(/*"invert"*/ STR(1890))) || is_bool(DsMap(bendmap).Value(/*"invert"*/ STR(1890)))) && array_length(VarType::CreateRef(axis)) == IntType(1))
				{
					self->bend_invert = vec3(DsMap(bendmap).Value(/*"invert"*/ STR(1890)));
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"invert"*/ STR(1890))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"invert"*/ STR(1890)))); i++)
							self->bend_invert.Real(axis.Value(i)) = ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"invert"*/ STR(1890))), i);
					}
					else
						self->bend_invert = vec3(false);
				
				
				if (self->bend_direction_legacy)
				{
					for (IntType i = X_; i <= Z_; i++)
					{
						if (self->bend_direction.Real(i) == e_bend_BOTH)
						{
							self->bend_direction_min.Real(i) = -IntType(180);
							self->bend_direction_max.Real(i) = IntType(180);
						}
						else
							if (self->bend_direction.Real(i) == e_bend_FORWARD)
							{
								self->bend_direction_min.Real(i) = IntType(0);
								self->bend_direction_max.Real(i) = IntType(180);
								self->bend_invert.Real(i) = !self->bend_invert.Real(i);
							}
							else
							{
								self->bend_direction_min.Real(i) = IntType(0);
								self->bend_direction_max.Real(i) = IntType(180);
							}
						
						
					}
				}
				self->bend_default_angle.Real(Z_) = IntType(0);
				if (is_real(DsMap(bendmap).Value(/*"angle"*/ STR(849))) && array_length(VarType::CreateRef(axis)) == IntType(1))
				{
					self->bend_default_angle = vec3(DsMap(bendmap).Value(/*"angle"*/ STR(849)));
				}
				else
					if (ds_list_valid(DsMap(bendmap).Value(/*"angle"*/ STR(849))))
					{
						for (IntType i = IntType(0); i < ds_list_size((IntType)(DsMap(bendmap).Value(/*"angle"*/ STR(849)))); i++)
							self->bend_default_angle.Real(axis.Value(i)) = ds_list_find_value((IntType)(DsMap(bendmap).Value(/*"angle"*/ STR(849))), i);
					}
				
				self->bend_inherit_angle.Real(Z_) = IntType(0);
				if (self->bend_inherit > 0 && Obj(self.otherId)->subAssetId == ID_obj_model_part)
					self->bend_inherit_angle = point3D_add(self->bend_default_angle, idVec(self.otherId, bend_inherit_angle));
				else
					self->bend_inherit_angle = self->bend_default_angle;
				
				self->ik_supported = tl_supports_ik(ScopeAny(self), false);
			}
			else
			{
				self->bend_part = null_;
				self->bend_axis.Real(Z_) = false;
				self->bend_direction.Real(Z_) = IntType(0);
				self->bend_default_angle.Real(Z_) = IntType(0);
				self->bend_inherit_angle.Real(Z_) = IntType(0);
				self->bend_inherit = false;
				self->bend_offset = IntType(0);
				self->bend_end_offset = IntType(0);
				self->bend_size = null_;
				self->bend_invert.Real(Z_) = false;
				self->bend_pos_offset = vec3(IntType(0));
				self->bend_direction_min = vec3(-IntType(180));
				self->bend_direction_max = vec3(IntType(180));
				self->ik_supported = false;
			}
			
			self->matrix = matrix_create(point3D(IntType(0), IntType(0), IntType(0)), self->rotation, vec3(IntType(1)));
			self->default_matrix = matrix_create(self->position, self->rotation, vec3(IntType(1)));
			if (Obj(self.otherId)->subAssetId == ID_obj_model_part && self->lock_bend > 0 && idInt(self.otherId, bend_part) != null_)
				self->default_matrix = matrix_multiply(self->default_matrix, model_part_get_bend_matrix(ScopeAny(self), { self.otherId, idVec(self.otherId, bend_inherit_angle), point3D(IntType(0), IntType(0), IntType(0)) }));
			self->bounds_start = point3D(no_limit, no_limit, no_limit);
			self->bounds_end = point3D(-no_limit, -no_limit, -no_limit);
			self->has_3d_plane = false;
			VarType shapelist = DsMap(map).Value(/*"shapes"*/ STR(1891));
			if (ds_list_valid(shapelist))
			{
				self->shape_list = ds_list_create();
				for (IntType p = IntType(0); p < ds_list_size((IntType)(shapelist)); p++)
				{
					VarType shape = model_file_load_shape(self, DsList(shapelist).Value(p), res);
					if (shape == null_)
						return null_;
					if (shape > IntType(0))
						ds_list_add({ self->shape_list, shape });
				}
			}
			else
				self->shape_list = null_;
			
			self->bounds_parts_start = self->bounds_start;
			self->bounds_parts_end = self->bounds_end;
			VarType partlist = DsMap(map).Value(/*"parts"*/ STR(1851));
			if (ds_list_valid(partlist))
			{
				self->part_list = ds_list_create();
				for (IntType p = IntType(0); p < ds_list_size((IntType)(partlist)); p++)
				{
					VarType part = model_file_load_part(ScopeAny(self), DsList(partlist).Value(p), root, res, model);
					if (part == null_)
						return null_;
					if (part > IntType(0))
						ds_list_add({ self->part_list, part });
				}
			}
			else
				self->part_list = null_;
			
			VecType boundsstartdef, boundsenddef;
			boundsstartdef = point3D_mul_matrix(self->bounds_parts_start, self->default_matrix);
			boundsenddef = point3D_mul_matrix(self->bounds_parts_end, self->default_matrix);
			idVec(self.otherId, bounds_parts_start).Real(X_) = min({ idVec(self.otherId, bounds_parts_start).Real(X_), boundsstartdef.Real(X_) });
			idVec(self.otherId, bounds_parts_start).Real(Y_) = min({ idVec(self.otherId, bounds_parts_start).Real(Y_), boundsstartdef.Real(Y_) });
			idVec(self.otherId, bounds_parts_start).Real(Z_) = min({ idVec(self.otherId, bounds_parts_start).Real(Z_), boundsstartdef.Real(Z_) });
			idVec(self.otherId, bounds_parts_end).Real(X_) = max({ idVec(self.otherId, bounds_parts_end).Real(X_), boundsenddef.Real(X_) });
			idVec(self.otherId, bounds_parts_end).Real(Y_) = max({ idVec(self.otherId, bounds_parts_end).Real(Y_), boundsenddef.Real(Y_) });
			idVec(self.otherId, bounds_parts_end).Real(Z_) = max({ idVec(self.otherId, bounds_parts_end).Real(Z_), boundsenddef.Real(Z_) });
			ds_list_add({ ObjType(obj_model_file, root)->file_part_list, self->id });
			if (self->has_3d_plane)
				ObjType(obj_model_file, root)->has_3d_plane = true;
			return self->id;
		}
		
		return VarType();
	}
	
}
